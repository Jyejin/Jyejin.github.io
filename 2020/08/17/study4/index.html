<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="yanm1ng&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" type="image/ico" href="/gallery/berry.png"/>
  
  <title>
    
      메모리 관리 | 개발계발 블로그
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
<meta name="generator" content="Hexo 4.2.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>개발계발 블로그</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>메모리 관리</h2>
  <p class="post-date">2020-08-17</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><br/>

<h3 id="메모리-관리"><a href="#메모리-관리" class="headerlink" title="메모리 관리?"></a>메모리 관리?</h3><p>프로세스를 실행할 때는 프로그램이 메모리에 적재 되어야 한다. 운영체제는 프로세스를 다중으로 운영하므로 메모리를 어떻게 사용하고, 배치할지, 메모리가 부족할 때는 어떻게 해야 하는지 등의 관리가 필요해진다.</p>
<h3 id="주소-지정-시점"><a href="#주소-지정-시점" class="headerlink" title="주소 지정 시점"></a>주소 지정 시점</h3><p>메모리 주소는 논리적 주소와 물리적 주소로 나뉜다. 논리적 주소는 프로세스 실행 시 생성되는 독자적인 가상의 주소 공간이며 물리적 주소는 실제 메모리 상의 위치를 의미한다. CPU가 논리적 주소를 통해 물리적 주소로 접근할 수 있어야 하는데, 논리적 주소를 물리적 주소로 매핑하는 것을 바인딩이라고 한다.</p>
<p>주소가 지정 되는 시점, 바인딩 되는 시점은 3가지로 나뉜다. </p>
<ul>
<li><p>컴파일 시점 바인딩</p>
<p>  프로그램이 메모리의 어느 위치에 적재될 지 컴파일 시점에 알 수 있다면 메모리 물리 주소를 지정할 수 있다.</p>
</li>
<li><p>로드 시점 바인딩</p>
<p>  프로그램의 실행이 시작될 때 물리 주소가 결정되는 방식으로 프로그램이 종료될 때까지 물리적 메모리 상의 위치가 고정된다.</p>
</li>
<li><p>실행 시점 바인딩</p>
<p>  프로그램 실행 중에 메모리 주소가 변경되는 방식이다. 하드웨어가 주소를 변경 해주는 하드웨어의 지원이 필요하다. ⇒ MMU</p>
</li>
</ul>
<p>** <strong>MMU</strong></p>
<p>논리 주소를 물리 주소로 변환하는 하드웨어이다. CPU에서 특정 논리 주소 위치에 저장된 데이터를 요청할 때 MMU가 자동으로 물리적 주소로 변환하여 해당 위치에 접근하는 것을 지원한다. 프로그램의 주소 공간이 메모리의 연속적인 공간에 적재되어 있다고 가정한다. </p>
<h3 id="메모리-할당법"><a href="#메모리-할당법" class="headerlink" title="메모리 할당법"></a>메모리 할당법</h3><ol>
<li>연속 할당</li>
</ol>
<p>메모리를 다수의 메모리로 분할하고 각 프로세스는 메모리의 연속적인 공간에 적재된다. 메모리 분할 방식으로는 고정 분할 방식과 가변 분할 방식이 있다. </p>
<ul>
<li>고정 분할 방식<ul>
<li>고정된 크기의 분할로 미리 나눔</li>
</ul>
</li>
<li>가변 분할 방식<ul>
<li>최초 적합 : 첫번째로 찾은 공간에 할당하는 방법, 시간 최적화</li>
<li>최적 적합 : 모든 공간 중에 수용 가능한 가장 작은 곳을 선택, 공간을 최적화</li>
<li>최악 적합 : 모든 공간 중에 수용 가능한 가장 큰 곳을 선택, 공간 낭비 발생</li>
</ul>
</li>
</ul>
<p>프로세스 실행 시, 프로세스에 필요한 메모리보다 같거나 큰 메모리 공간을 찾아 프로세스가 사용할 수 있도록 배정한다. </p>
<p>연속 할당에는 단편화라는 문제가 발생하는데, 단편화란 프로세스의 반복적인 실행과 종료로 인해 복수의 사용하지 않는 메모리 공간, 즉 구멍이 메모리 상에 발생하는 것을 의미한다. 여유 메모리 공간이 하나의 할당 요청을 만족시키기에는 충분하지만 구멍이 연속적이지 않아 할당할 수 없는 문제를 외부 단편화라고 한다. 그리고 할당된 메모리가 요청한 메모리 크기보다 커 남는 공간을 내부 단편화라고 한다. 이 문제를 해결하기 위해 남은 구멍들을 합치는 압축 기능을 사용하여 연속적인 메모리 공간을 만들고 프로세스에 할당한다.</p>
<ol start="2">
<li>불연속 할당</li>
</ol>
<p>연속적인 메모리 공간이 아닌 불연속적인 메모리 공간을 사용함으로써 압축에 드는 시간을 없앤다. 불연속 할당 기법으로는 페이징 기법과 세그먼트 기법이 있다.</p>
<ul>
<li><p>페이징 기법</p>
<p>  프로세스의 주소 공간을 동일한 크기의 페이지 단위로 나누어 불연속적인 메모리 공간에 할당하는 방식이다. 물리적 메모리를 프로세스의 페이지 크기와 동일한 크기로 나누고 메모리에 페이지를 할당한다. 프로세스의 몇번째 페이지가 물리적 메모리에 몇번째 위치에 들어있다는 정보가 필요한데, 이 정보를 <code>페이지 테이블</code>이 갖고 있다. 페이지 테이블을 사용하여 논리주소를 물리주소로 매핑한다.</p>
<p>   각 프로세스의 메모리 영역 전체를 물리적 공간에 적재할 필요없으며 일부는 backing store에 일시적으로 보관하는 것이 가능하다. </p>
<p>  페이지 크기에 맞춰 메모리를 나누기 때문에 외부 단편화 문제가 발생하지 않지만 내부 단편화는 발생한다.</p>
</li>
<li><p>세그먼트 기법</p>
<p>  페이징 기법에서는 가상 메모리를 같은 크기의 페이지로 분리했다면, 세그먼트 기법은 서로 다른 크기의 논리적 단위인 세그먼트로 분할하고 메모리를  할당하며 주소를 반환한다. 세그먼트들은 크기가 각각 다르며 연속적인 메모리 공간에 저장되어 있다. 세그먼트 가상의 주소는 세그먼트 번호와 블록 내 세그먼트의 길이를 나타낸다. 페이징 기법에는 페이징 테이블이 있는 것처럼 세그먼트 기법에는 세그먼트 테이블이 있어 실제 주소를 매핑하는 저장 정보를 포함하고 있다. 세그먼트 테이블에는 항목별로 Base(세그먼트 시작 주소)와 Limit(세그먼트 길이)의 정보를 가지고 있다.</p>
</li>
</ul>
</section>
    <!-- Tags START -->
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2020/08/09/project-3/">
        <span class="nav-arrow">← </span>
        
          pytest 사용기 - fixture, scope
        
      </a>
    
    
      <a class="nav-right" href="/2020/08/23/study3/">
        
          IPC - 프로세스간 통신
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#메모리-관리"><span class="toc-nav-text">메모리 관리?</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#주소-지정-시점"><span class="toc-nav-text">주소 지정 시점</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#메모리-할당법"><span class="toc-nav-text">메모리 할당법</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://jyejin.github.io/2020/08/17/study4/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2020 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng" target="_blank" rel="noopener">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>

  </body>
</html>