<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="yanm1ng&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" type="image/ico" href="/gallery/berry.png"/>
  
  <title>
    
      역전파를 사용하여 모델 학습하기 | 개발계발 블로그
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
<meta name="generator" content="Hexo 4.2.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>개발계발 블로그</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>역전파를 사용하여 모델 학습하기</h2>
  <p class="post-date">2020-05-12</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><br/>

<p>오차역전파를 사용한 학습도 손실함수를 최소화하는 가중치를 찾는 것을 목표로합니다. 다만, 역전파는 가중치를 구함에 있어 연쇄법칙에 기반한 국소적 미분을 활용합니다. 순전파와 비교했을 때 훨씬 빠른 시간 안에 효울적으로 계산한다는 장점이 있습니다. 이번에는 역전파법을 사용하여 모델 학습을 진행해 보겠습니다.</p>
<p>먼저, 라이브러리와 공통함수를 읽어옵니다.</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#install.packages("dslabs")</span></span><br><span class="line">    <span class="keyword">library</span>(dslabs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">source</span>(<span class="string">"./functions.R"</span>)</span><br><span class="line">    <span class="keyword">source</span>(<span class="string">"./utils.R"</span>)</span><br><span class="line">    <span class="keyword">source</span>(<span class="string">"./model.R"</span>)</span><br></pre></td></tr></table></figure>

<p>1개의 은닉층을 갖는 네트워크를 생성합니다. 네트워크는 순전파와 동일합니다.</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TwoLayerNet &lt;- <span class="keyword">function</span>(input_size, hidden_size, output_size, weight_init_std  =  <span class="number">0.01</span>) &#123;</span><br><span class="line">  W1 &lt;- weight_init_std * matrix(rnorm(n  =  input_size*hidden_size), nrow  =  input_size, ncol  =  hidden_size)</span><br><span class="line">  b1 &lt;- matrix(rep(<span class="number">0</span>,hidden_size), nrow = <span class="number">1</span>, ncol = hidden_size)</span><br><span class="line">  W2 &lt;- weight_init_std * matrix(rnorm(n  =  hidden_size*output_size), nrow  =  hidden_size, ncol  =  output_size)</span><br><span class="line">  b2 &lt;- matrix(rep(<span class="number">0</span>,output_size),nrow = <span class="number">1</span>, ncol = output_size)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (list(W1 = W1, b1 = b1, W2 = W2, b2 = b2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>데이터를 불러와 트레이닝셋과 테스트셋으로 분리하는 <code>init()</code>함수를 생성합니다.</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">init &lt;- <span class="keyword">function</span>()&#123;</span><br><span class="line">  mnist_data &lt;- get_data()</span><br><span class="line">  <span class="comment">#손글씨 데이터</span></span><br><span class="line">  x_train_normalize &lt;&lt;- mnist_data$x_train </span><br><span class="line">  x_test_normalize &lt;&lt;- mnist_data$x_test</span><br><span class="line">  <span class="comment">#정답 레이블</span></span><br><span class="line">  t_train_onehotlabel &lt;&lt;- making_one_hot_label(mnist_data$t_train,<span class="number">60000</span>, <span class="number">10</span>)</span><br><span class="line">  t_test_onehotlabel &lt;&lt;- making_one_hot_label(mnist_data$t_test,<span class="number">10000</span>, <span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>앞서 역전파에서는 국소적 미분을 사용한다고 했습니다. 순전파와 반대방향으로 국소적 미분을 곱하여 이전 노드들에 값을 전달하는 것인데, 국소적 미분은 순전파 때의 미분을 구한다는 뜻입니다. 다시 말해, 순전파 때의 미분 값을 구해 다음 노드에 전달하는 함수가 필요합니다.<br>다음 코드는 순전파 때와 마찬가지로 입력신호와 가중치를 계산하고 Relu함수를 거쳐 다음 노드로 전달합니다.</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">forward &lt;- <span class="keyword">function</span>(x)&#123;</span><br><span class="line">  Affine_1 &lt;- Affine.forward(network$W1, network$b1, x)</span><br><span class="line">  Relu_1 &lt;- Relu.forward(Affine_1$out)</span><br><span class="line">  Affine_2 &lt;- Affine.forward(network$W2, network$b2, Relu_1$out)</span><br><span class="line">  <span class="keyword">return</span>(list(x = Affine_2$out, Affine_1.forward = Affine_1, Affine_2.forward = Affine_2, Relu_1.forward = Relu_1))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>역전파도 마찬가지로 손실함수를 계산합니다. </p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">loss &lt;- <span class="keyword">function</span>(model.forward, x, t)&#123;</span><br><span class="line">  temp &lt;- model.forward(x)</span><br><span class="line">  y &lt;- temp$x</span><br><span class="line">  last_layer.forward &lt;- SoftmaxWithLoss.forward(y, t)</span><br><span class="line">  <span class="keyword">return</span>(list(loss = last_layer.forward$loss, softmax = last_layer.forward, predict =  temp))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>순전파와 달리 마지막 노드에서부터 거꾸로 계산해 기울기를 구합니다.</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gradient &lt;- <span class="keyword">function</span>(model.forward, x, t) &#123;</span><br><span class="line">  <span class="comment"># 순전파</span></span><br><span class="line">  temp &lt;- loss(model.forward, x, t)</span><br><span class="line">  <span class="comment"># 역전파</span></span><br><span class="line">  dout &lt;- <span class="number">1</span></span><br><span class="line">  last.backward &lt;- SoftmaxWithLoss.backward(temp$softmax, dout)</span><br><span class="line">  Affine_2.backward &lt;- Affine.backward(temp$predict$Affine_2.forward, dout  =  last.backward$dx)</span><br><span class="line">  Relu_1.backward &lt;- Relu.backward(temp$predict$Relu_1.forward, dout  =  Affine_2.backward$dx)</span><br><span class="line">  Affine_1.backward &lt;- Affine.backward(temp$predict$Affine_1.forward, dout  =  Relu_1.backward$dx)</span><br><span class="line">  grads  &lt;- list(W1  =  Affine_1.backward$dW, b1  =  Affine_1.backward$db, W2  =  Affine_2.backward$dW, b2  =  Affine_2.backward$db)</span><br><span class="line">  <span class="keyword">return</span>(grads)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>다음은 학습을 실제로 진행하는 코드입니다.</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">train_model &lt;- <span class="keyword">function</span>(batch_size, iters_num, learning_rate, debug=<span class="literal">FALSE</span>)&#123;</span><br><span class="line">  <span class="comment">#seperate train, test data</span></span><br><span class="line">  init()</span><br><span class="line">  train_size &lt;- dim(x_train_normalize)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">  iter_per_epoch &lt;- max(train_size / batch_size)</span><br><span class="line">  <span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:iters_num)&#123;</span><br><span class="line">      batch_mask &lt;- sample(train_size ,batch_size)</span><br><span class="line">      x_batch &lt;- x_train_normalize[batch_mask,]</span><br><span class="line">      t_batch &lt;- t_train_onehotlabel[batch_mask,]</span><br><span class="line"></span><br><span class="line">      grad &lt;- gradient(model.forward=forward, x_batch, t_batch)</span><br><span class="line">      <span class="comment">#update weights and biases using SGD</span></span><br><span class="line">      network &lt;&lt;- sgd.update(network,grad,lr=learning_rate)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(debug == <span class="literal">TRUE</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(i %% iter_per_epoch == <span class="number">0</span>)&#123;</span><br><span class="line">              train_acc &lt;- model.evaluate(forward, x_train_normalize, t_train_onehotlabel)</span><br><span class="line">              test_acc &lt;- model.evaluate(forward, x_test_normalize, t_test_onehotlabel)</span><br><span class="line">              print(c(train_acc, test_acc))</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  train_accuracy = model.evaluate(forward, x_train_normalize, t_train_onehotlabel)</span><br><span class="line">  test_accuracy = model.evaluate(forward, x_test_normalize, t_test_onehotlabel)</span><br><span class="line">  <span class="keyword">return</span>(c(train_accuracy, test_accuracy))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>train_model()</code>함수 중간에 <code>sg.update()</code>함수는 경사하강법으로 변경된 가중치를 업데이트하는 역할을 합니다.<br>코드는 아래와 같습니다.</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sgd.update &lt;- <span class="keyword">function</span>(network, grads, lr = <span class="number">0.01</span>)&#123;</span><br><span class="line">  <span class="keyword">for</span>(i <span class="keyword">in</span> names(network))&#123;network[[i]] &lt;- network[[i]] - (grads[[i]]*lr)&#125;</span><br><span class="line">  <span class="keyword">return</span>(network)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제 모든 준비를 마쳤습니다. 네트워크를 생성한 후 모델을 학습시켜봅니다.</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">network &lt;&lt;- TwoLayerNet(input_size = <span class="number">784</span>, hidden_size = <span class="number">50</span>, output_size = <span class="number">10</span>)</span><br><span class="line">train_model(<span class="number">100</span>, <span class="number">10000</span>, <span class="number">0.1</span>, <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure>

<p>위 코드를 실행시키고 3분 정도 지나면 아래와 같은 출력화면이 나올 것입니다. 한 행의 첫 번째 숫자는 훈련데이터 셋에 대한 정확도, 두 번째 숫자는 테스트 셋에 대한 정확도를 나타냅니다. 그리고 하나의 행은 1에폭(epoch)을 의미합니다. 에폭을 진행할수록 정확도가 높아지는 것을 확인할 수 있습니다!</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>] <span class="number">0.9048</span> <span class="number">0.9059</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">0.9228</span> <span class="number">0.9247</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">0.9355833</span> <span class="number">0.9343000</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">0.9436167</span> <span class="number">0.9416000</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">0.9496167</span> <span class="number">0.9470000</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">0.9563167</span> <span class="number">0.9519000</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">0.9602167</span> <span class="number">0.9555000</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">0.9629167</span> <span class="number">0.9558000</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">0.9664833</span> <span class="number">0.9603000</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">0.9680333</span> <span class="number">0.9619000</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">0.9711167</span> <span class="number">0.9635000</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">0.97315</span> <span class="number">0.96520</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">0.97445</span> <span class="number">0.96570</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">0.9754167</span> <span class="number">0.9659000</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">0.9771167</span> <span class="number">0.9698000</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">0.9779</span> <span class="number">0.9679</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">0.9776833</span> <span class="number">0.9680000</span></span><br></pre></td></tr></table></figure>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#딥러닝" >
    <span class="tag-code">딥러닝</span>
  </a>

  <a href="/tags#project" >
    <span class="tag-code">project</span>
  </a>

  <a href="/tags#역전파" >
    <span class="tag-code">역전파</span>
  </a>

  <a href="/tags#모델학습" >
    <span class="tag-code">모델학습</span>
  </a>

  <a href="/tags#모델링" >
    <span class="tag-code">모델링</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2020/05/04/project1-3/">
        <span class="nav-arrow">← </span>
        
          순전파를 사용하여 모델 학습하기
        
      </a>
    
    
      <a class="nav-right" href="/2020/05/22/book3-1/">
        
          헤더와 바디
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="nav">none</ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://jyejin.github.io/2020/05/12/project1-4/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2020 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng" target="_blank" rel="noopener">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>

  </body>
</html>