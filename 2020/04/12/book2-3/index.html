<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="yanm1ng&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" type="image/ico" href="/gallery/berry.png"/>
  
  <title>
    
      JavaScript 객체 지향[1] - this/constructor/prototype | 개발계발 블로그
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
<meta name="generator" content="Hexo 4.2.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>개발계발 블로그</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>JavaScript 객체 지향[1] - this/constructor/prototype</h2>
  <p class="post-date">2020-04-12</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><br/>

<p>자바스크립트는 객체지향 스크립트 언어이다.</p>
<p>객체지향을 내 기준에서 간단하게 설명하면 자주 사용하는 걸  구조화해놓는 것이다.</p>
<p>그러면 필요할 때마다 만들지 않아도 되고 이미 만들어진 걸 가져다 쓰기만 하면 된다.</p>
<p>여기서 미리 만들어 놓는다는 개념이 자바스크립트에서는 함수,클래스가 된다.</p>
  <a id="more"></a> 


<p>자바스크립트가 객체지향 언어인 만큼 객체 관련 기능들을 제공한다. 이번에는 this, constructor, prototype을 알아본다.</p>
<p>*생활 코딩 javascript 객체지향 내용을 공부하며 정리한 것입니다.</p>
<p>1.this</p>
<ul>
<li>자신을 가리키는 특수한 키워드로 오브젝트, 클래스 안에서 선언한 변수 및 함수를 자기 안에서 호출할 때 사용한다.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var fisrt = 5;</span><br><span class="line">var second = 10;</span><br><span class="line">var kim = &#123;</span><br><span class="line">	name:<span class="string">"kim"</span>,</span><br><span class="line">    first:10,</span><br><span class="line">    second:20,</span><br><span class="line">    sum:<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    	<span class="built_in">return</span> this.first+this.second;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var lee = &#123;</span><br><span class="line">	name:<span class="string">"lee"</span>,</span><br><span class="line">    first:10,</span><br><span class="line">    second:20,</span><br><span class="line">    sum:<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    	<span class="built_in">return</span> first+second;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"> console.log(<span class="string">"kim.sum()"</span>, kim.sum()); //kim.sum() 30</span><br><span class="line"> console.log(<span class="string">"lee.sum()"</span>, lee.sum()); //lee.sum() 15</span><br></pre></td></tr></table></figure>
<p>위 코드를 보면 kim은 오브젝트로써 name과 점수를 나타내는 first, second, 그리고 그 합계를 구하게 해주는 sum()이 있다. kim의 합계를 알고 싶을 때는 kim의 메서드 함수인 sum()을 호출해서 확인하면 된다. (= kim.sum())</p>
<p>sum()을 살펴보면, first, second 변수를 더한 값을 리턴하는데, 이 때 first, second 앞에 this가 붙어서 객체 안의 first, second 임을 명시하고 있다. 그렇기 때문에 리턴 값은 30 이 된다.</p>
<p>반면에, lee의 sum() this 없이 first와 second의 합을 리턴하고 있는데 결과 값은 30이 아닌 15가 된다.</p>
<p>lee 내의 first와 second가 아닌 전역변수의 fisrt, second의 합을 구했기 때문이다.</p>
<ol start="2">
<li>생성자(constructor)</li>
</ol>
<p>만약 kim,lee 처럼 똑같은 구조를 가진 변수가 1억 개 필요하다고 한다면 1억 번 다 똑같이 정의해야 할까? 결국 1억 번을 다 정의했는데 3번째 점수인 third가 생긴다면 각각의 변수에 third를 추가하는 1억 번의 작업을 해야 할까? 같은 구조의 변수라면 구조를 미리 정의해놓고 가져다 쓸 수 있는데 그 방법이 constructor이다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Person(name, first, second)&#123;</span><br><span class="line">    this.name=name;</span><br><span class="line">    this.first=first;</span><br><span class="line">    this.second=second;</span><br><span class="line">    this.sum = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> this.first+this.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var kim = new Person(<span class="string">'kim'</span>, 10, 20);</span><br><span class="line">var lee = new Person(<span class="string">'lee'</span>, 10, 10);</span><br><span class="line">console.log(<span class="string">"kim.sum()"</span>, kim.sum()); //kim.sum() 30</span><br><span class="line">console.log(<span class="string">"lee.sum()"</span>, lee.sum()); //lee.sum() 20</span><br></pre></td></tr></table></figure>
<p>먼저, 같은 구조를 정의하는 Person 함수를 만든다. 구조는 같아도 이름,점수는 다르기 때문에 값을 받는 파라미터도 추가한다. 그리고 Person 앞에 new를 붙이고 변수를 선언하면 된다. new를 붙이면 새로운 객체를 생성하는 생성자 함수가 된다.  즉, 함수로 객체를 생성한다는 말은 생성자 함수로 선언한다와 같다고 보면 된다.</p>
<p>third를 추가하고 싶으면 Person 내에다가 한 번만 추가하면 된다.</p>
<ol start="3">
<li>prototype</li>
</ol>
<p>앞서 정의한 Person 함수에 new를 붙이면 함수로 객체(kim, lee)를 생성할 수 있었다. 그런데 생성자 함수를 호출할 때마다 공통적으로 사용하는 sum()을 계속 생성하는데, 이는 메모리를 차지하게 된다. 공통적으로 사용하는 함수는 한 번만 선언하어 좋지 않을까? 이럴 때 사용해 볼 수 있는 것이 prototype이다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Person(name, first, second, third)&#123;</span><br><span class="line">    this.name=name;</span><br><span class="line">    this.first=first;</span><br><span class="line">    this.second=second;   </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Person.prototype.sum = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'prototype : '</span>+(this.first+this.second);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var kim = new Person(<span class="string">'kim'</span>, 10, 20);</span><br><span class="line">kim.sum = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'this : '</span>+(this.first+this.second);</span><br><span class="line">&#125;</span><br><span class="line">var lee = new Person(<span class="string">'lee'</span>, 10, 10);</span><br><span class="line">console.log(<span class="string">"kim.sum()"</span>, kim.sum());</span><br><span class="line">console.log(<span class="string">"lee.sum()"</span>, lee.sum());</span><br></pre></td></tr></table></figure>
<p>위 코드처럼 prototype을 사용해 sum 함수를 정의하면 된다. 그런데 저렇게 하면 Person에 sum()이 추가돼서 똑같아지는 거 아닌가 생각했는데, 확인해보니 아래와 같았다.</p>
<img src="/gallery/book2-3-1.jpg" width="400px" />

<p>sum을 추가하고 나서 다시 확인해봤을 때 sum이 추가되지는 않았다…! 호오…</p>
<p>하지만 Person의 prototype을 확인해 보면, sum()이 정의되어 있다.</p>
<img src="/gallery/book2-3-2.jpg" width="400px" />

<p>이 부분을 간단하게 설명하면 함수를 생성할 때 함수의 prototype object도 같이 생성되는데 생성자 함수로 만들어진 객체도 이 prototype에 접근할 수 있다. 그렇기 때문에 prototype의 속성을 사용할 수 있는 것이다. 여기서는 sum()이 된다.</p>
<p>생성자 함수로 객체가 여러 개 만들어져도 하나의 prototype을 공유하고 있기 때문에 공통적으로 적용할 수 있고 메모리를 객체 개수만큼 사용하지 않는다. </p>
<p>prototype은 내용이 많아 보여서 좀 더 알아봐야겠다.</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#study" >
    <span class="tag-code">study</span>
  </a>

  <a href="/tags#js" >
    <span class="tag-code">js</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2020/04/12/book2-2/">
        <span class="nav-arrow">← </span>
        
          JavaScript 실행 컨텍스트
        
      </a>
    
    
      <a class="nav-right" href="/2020/04/12/book2-4/">
        
          Javascript 객체 지향[2] - class 상속/super/object 상속/__proto__ vs prototype
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="nav">none</ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://jyejin.github.io/2020/04/12/book2-3/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2020 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng" target="_blank" rel="noopener">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>

  </body>
</html>