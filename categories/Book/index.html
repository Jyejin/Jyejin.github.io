<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Category: Book - 정지니 블로그</title><meta property="og:type" content="blog"><meta property="og:title" content="정지니 블로그"><meta property="og:url" content="https://jyejin.github.io/"><meta property="og:site_name" content="정지니 블로그"><meta property="og:locale" content="en_US"><meta property="article:author" content="Yejin Jeong"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://jyejin.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jyejin.github.io"},"headline":"정지니 블로그","image":["https://jyejin.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Yejin Jeong"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="정지니 블로그" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">Categories</a></li><li class="is-active"><a href="#" aria-current="page">Book</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-04-12T09:09:49.000Z" title="2020-04-12T09:09:49.000Z">2020-04-12</time><span class="level-item"><a class="link-muted" href="/categories/Book/">Book</a><span> / </span><a class="link-muted" href="/categories/Book/%EC%9D%B8%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">인사이드 자바스크립트</a></span><span class="level-item">4 minutes read (About 664 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/04/12/book2-4/">Javascript 객체 지향[2] - class 상속/super/object 상속/__proto__ vs prototype</a></h1><div class="content"><br/>

<h3 id="1-class-상속"><a href="#1-class-상속" class="headerlink" title="1. class 상속"></a>1. class 상속</h3><p>클래스를 생성할 때 다른 클래스를 상속 받을 수 있는데, 새로 만들어지는 클래스가 자식 클래스, 상속하는 클래스가 부모 클래스가 된다. 자바스크립트에서 상속은 extends를 쓴다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">	constructor(name, first, second)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.first = first;</span><br><span class="line">    this.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">sum</span></span>()&#123;</span><br><span class="line">    	<span class="built_in">return</span> this.first + this.second</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PersonPlus extends Person&#123;</span><br><span class="line">	<span class="function"><span class="title">avg</span></span>()&#123;</span><br><span class="line">    	<span class="built_in">return</span> (this.first + this.second)/2;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var kim = new PersonPlus(<span class="string">'kim'</span>,10,20);</span><br><span class="line">console.log(<span class="string">"kim.sum()"</span>,kim.sum()); //kim.sum() 30</span><br><span class="line">console.log(<span class="string">"kim.avg()"</span>,kim.avg());  //kim.avg() 15</span><br></pre></td></tr></table></figure>
<p>PersonPlus 클래스에 sum()메서드가 없음에도 불구하고 kim 객체에 sum()을 호출하니 에러없이 결과값이 나왔다. 이는 PersonPlus의 부모 클래스 Person의 sum()메서드를 사용한 것이다. 약간 옆길로 새서 만약 Person과 PersonPlus 모두 sum()이 있었다면 PersonPlus 클래스의 sum()을 사용한다. 부모 클래스와 같은 함수명을 새로 정의하는 것을 오버라이딩이라고 한다.</p>
<h3 id="2-super"><a href="#2-super" class="headerlink" title="2. super"></a>2. super</h3><p>클래스를 생성할 때, 부모 클래스의 기능을 활용해서 메서드나 변수를 선언하고 싶다면 super를 사용하면 된다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    constructor(name, first, second)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.first = first;</span><br><span class="line">        this.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">sum</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> this.first+this.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PersonPlus extends Person&#123;</span><br><span class="line">	constructor(name,first,second,third)&#123;</span><br><span class="line">    	super(name,first,second);</span><br><span class="line">        this.third = third;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">sum</span></span>()&#123;</span><br><span class="line">    	<span class="built_in">return</span> super.sum() + this.third;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">avg</span></span>()&#123;</span><br><span class="line">    	<span class="built_in">return</span> (super.sum() + this.third)/3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var kim = new PersonPlus(<span class="string">'kim'</span>,10,20,30);</span><br><span class="line">console.log(<span class="string">"kim.sum()"</span>, kim.sum());  //kim.sum() 60</span><br><span class="line">console.log(<span class="string">"kim.avg()"</span>, kim.avg()); //kim.avg() 20</span><br></pre></td></tr></table></figure>
<p> PersonPlus constructor에 super()를 사용해서 Person constructor에 선언된 name,first,second 변수를 가져다 썼으며, 정의되지 않은 third는 새로 선언했다. 그리고 sum()과 avg메서드에서는 Person sum()메서드를 활용해서 함수를 정의하고 있다. </p>
<h3 id="3-object-상속"><a href="#3-object-상속" class="headerlink" title="3. object 상속"></a>3. object 상속</h3><p>중괄호{}로 표현하는 object도 상속이 가능하다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var superObj = &#123;superVal:<span class="string">'super'</span>&#125;;</span><br><span class="line"></span><br><span class="line">//case1</span><br><span class="line">var subObj = &#123;subVal:<span class="string">'sub'</span>&#125;;</span><br><span class="line">subObj.__proto__ = superObj;</span><br><span class="line"></span><br><span class="line">//case2</span><br><span class="line">var subObj = Object.create(superObj);</span><br><span class="line"></span><br><span class="line">//공통</span><br><span class="line">subObj.subVal = <span class="string">'sub'</span>;</span><br><span class="line">console.log(<span class="string">'subObj.subVal =&gt;'</span>, subObj.subVal); //subObj.subVal =&gt; sub</span><br><span class="line">console.log(<span class="string">'subObj.superVal =&gt;'</span>, subObj.superVal); //subObj.superVal =&gt; super</span><br><span class="line">subObj.superVal = <span class="string">'sub'</span>;</span><br><span class="line">console.log(<span class="string">'superObj.superVal =&gt;'</span>, superObj.superVal); //superObj.superVal =&gt; super</span><br></pre></td></tr></table></figure>

<p>case1과 case2의 결과값은 같다. superObj객체에는 superVal, subObj 객체에는 subVal이 있는데 상속을 통해 subObj에서도 superVal을 호출할 수 있었다. 단 subObj에서 superVal 값을 변경했을 때 subObj에서만 변경될 뿐, 참조하고 있는 SuperObj의 값은 변하지 않는다.</p>
<h3 id="4-95-95-proto-vs-prototype"><a href="#4-95-95-proto-vs-prototype" class="headerlink" title="4. &#95;&#95;proto__ vs prototype"></a>4. &#95;&#95;proto__ vs prototype</h3><p>객체가 생성될 때 객체가 참조하는 prototype 타입 객체도 함께 생성된다. 객체의 &#95;&#95;proto__는 prototype 객체를 참조하고, prototype 객체의 constructor 프로퍼티는 생성된 객체를 참조한다.</p>
<p>즉 서로가 서로를 참조하는 것이다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-04-12T09:06:33.000Z" title="2020-04-12T09:06:33.000Z">2020-04-12</time><span class="level-item"><a class="link-muted" href="/categories/Book/">Book</a><span> / </span><a class="link-muted" href="/categories/Book/%EC%9D%B8%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">인사이드 자바스크립트</a></span><span class="level-item">8 minutes read (About 1220 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/04/12/book2-3/">JavaScript 객체 지향[1] - this/constructor/prototype</a></h1><div class="content"><br/>

<p>자바스크립트는 객체지향 스크립트 언어이다.</p>
<p>객체지향을 내 기준에서 간단하게 설명하면 자주 사용하는 걸  구조화해놓는 것이다.</p>
<p>그러면 필요할 때마다 만들지 않아도 되고 이미 만들어진 걸 가져다 쓰기만 하면 된다.</p>
<p>여기서 미리 만들어 놓는다는 개념이 자바스크립트에서는 함수,클래스가 된다.</p>
<p>자바스크립트가 객체지향 언어인 만큼 객체 관련 기능들을 제공한다. 이번에는 this, constructor, prototype을 알아본다.</p>
<p>*생활 코딩 javascript 객체지향 내용을 공부하며 정리한 것입니다.</p>
<p>1.this</p>
<ul>
<li>자신을 가리키는 특수한 키워드로 오브젝트, 클래스 안에서 선언한 변수 및 함수를 자기 안에서 호출할 때 사용한다.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var fisrt = 5;</span><br><span class="line">var second = 10;</span><br><span class="line">var kim = &#123;</span><br><span class="line">	name:<span class="string">"kim"</span>,</span><br><span class="line">    first:10,</span><br><span class="line">    second:20,</span><br><span class="line">    sum:<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    	<span class="built_in">return</span> this.first+this.second;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var lee = &#123;</span><br><span class="line">	name:<span class="string">"lee"</span>,</span><br><span class="line">    first:10,</span><br><span class="line">    second:20,</span><br><span class="line">    sum:<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    	<span class="built_in">return</span> first+second;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"> console.log(<span class="string">"kim.sum()"</span>, kim.sum()); //kim.sum() 30</span><br><span class="line"> console.log(<span class="string">"lee.sum()"</span>, lee.sum()); //lee.sum() 15</span><br></pre></td></tr></table></figure>
<p>위 코드를 보면 kim은 오브젝트로써 name과 점수를 나타내는 first, second, 그리고 그 합계를 구하게 해주는 sum()이 있다. kim의 합계를 알고 싶을 때는 kim의 메서드 함수인 sum()을 호출해서 확인하면 된다. (= kim.sum())</p>
<p>sum()을 살펴보면, first, second 변수를 더한 값을 리턴하는데, 이 때 first, second 앞에 this가 붙어서 객체 안의 first, second 임을 명시하고 있다. 그렇기 때문에 리턴 값은 30 이 된다.</p>
<p>반면에, lee의 sum() this 없이 first와 second의 합을 리턴하고 있는데 결과 값은 30이 아닌 15가 된다.</p>
<p>lee 내의 first와 second가 아닌 전역변수의 fisrt, second의 합을 구했기 때문이다.</p>
<ol start="2">
<li>생성자(constructor)</li>
</ol>
<p>만약 kim,lee 처럼 똑같은 구조를 가진 변수가 1억 개 필요하다고 한다면 1억 번 다 똑같이 정의해야 할까? 결국 1억 번을 다 정의했는데 3번째 점수인 third가 생긴다면 각각의 변수에 third를 추가하는 1억 번의 작업을 해야 할까? 같은 구조의 변수라면 구조를 미리 정의해놓고 가져다 쓸 수 있는데 그 방법이 constructor이다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Person(name, first, second)&#123;</span><br><span class="line">    this.name=name;</span><br><span class="line">    this.first=first;</span><br><span class="line">    this.second=second;</span><br><span class="line">    this.sum = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> this.first+this.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var kim = new Person(<span class="string">'kim'</span>, 10, 20);</span><br><span class="line">var lee = new Person(<span class="string">'lee'</span>, 10, 10);</span><br><span class="line">console.log(<span class="string">"kim.sum()"</span>, kim.sum()); //kim.sum() 30</span><br><span class="line">console.log(<span class="string">"lee.sum()"</span>, lee.sum()); //lee.sum() 20</span><br></pre></td></tr></table></figure>
<p>먼저, 같은 구조를 정의하는 Person 함수를 만든다. 구조는 같아도 이름,점수는 다르기 때문에 값을 받는 파라미터도 추가한다. 그리고 Person 앞에 new를 붙이고 변수를 선언하면 된다. new를 붙이면 새로운 객체를 생성하는 생성자 함수가 된다.  즉, 함수로 객체를 생성한다는 말은 생성자 함수로 선언한다와 같다고 보면 된다.</p>
<p>third를 추가하고 싶으면 Person 내에다가 한 번만 추가하면 된다.</p>
<ol start="3">
<li>prototype</li>
</ol>
<p>앞서 정의한 Person 함수에 new를 붙이면 함수로 객체(kim, lee)를 생성할 수 있었다. 그런데 생성자 함수를 호출할 때마다 공통적으로 사용하는 sum()을 계속 생성하는데, 이는 메모리를 차지하게 된다. 공통적으로 사용하는 함수는 한 번만 선언하어 좋지 않을까? 이럴 때 사용해 볼 수 있는 것이 prototype이다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Person(name, first, second, third)&#123;</span><br><span class="line">    this.name=name;</span><br><span class="line">    this.first=first;</span><br><span class="line">    this.second=second;   </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Person.prototype.sum = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'prototype : '</span>+(this.first+this.second);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var kim = new Person(<span class="string">'kim'</span>, 10, 20);</span><br><span class="line">kim.sum = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'this : '</span>+(this.first+this.second);</span><br><span class="line">&#125;</span><br><span class="line">var lee = new Person(<span class="string">'lee'</span>, 10, 10);</span><br><span class="line">console.log(<span class="string">"kim.sum()"</span>, kim.sum());</span><br><span class="line">console.log(<span class="string">"lee.sum()"</span>, lee.sum());</span><br></pre></td></tr></table></figure>
<p>위 코드처럼 prototype을 사용해 sum 함수를 정의하면 된다. 그런데 저렇게 하면 Person에 sum()이 추가돼서 똑같아지는 거 아닌가 생각했는데, 확인해보니 아래와 같았다.</p>
<img src="/gallery/book2-3-1.jpg" width="400px" />

<p>sum을 추가하고 나서 다시 확인해봤을 때 sum이 추가되지는 않았다…! 호오…</p>
<p>하지만 Person의 prototype을 확인해 보면, sum()이 정의되어 있다.</p>
<img src="/gallery/book2-3-2.jpg" width="400px" />

<p>이 부분을 간단하게 설명하면 함수를 생성할 때 함수의 prototype object도 같이 생성되는데 생성자 함수로 만들어진 객체도 이 prototype에 접근할 수 있다. 그렇기 때문에 prototype의 속성을 사용할 수 있는 것이다. 여기서는 sum()이 된다.</p>
<p>생성자 함수로 객체가 여러 개 만들어져도 하나의 prototype을 공유하고 있기 때문에 공통적으로 적용할 수 있고 메모리를 객체 개수만큼 사용하지 않는다. </p>
<p>prototype은 내용이 많아 보여서 좀 더 알아봐야겠다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-04-12T08:57:58.000Z" title="2020-04-12T08:57:58.000Z">2020-04-12</time><span class="level-item"><a class="link-muted" href="/categories/Book/">Book</a><span> / </span><a class="link-muted" href="/categories/Book/%EC%9D%B8%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">인사이드 자바스크립트</a></span><span class="level-item">6 minutes read (About 879 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/04/12/book2-2/">JavaScript 실행 컨텍스트</a></h1><div class="content"><br/>

<h3 id="1-실행-컨텍스트"><a href="#1-실행-컨텍스트" class="headerlink" title="1. 실행 컨텍스트"></a>1. 실행 컨텍스트</h3><p>특정 프로그램(크롬,엑셀…)을 실행하면 프로세스도 같이 실행되듯이 코드를 실행하면 실행 컨텍스트도 같이 실행된다. 코드 진행과 컨텍스트는 불가분의 관계이며, 컨텍스트에는드 실행 순서 등 실행에 필요한 메타 정보를 담고 있다.</p>
<p>컨텍스트 단위는 전역 코드에 대한 컨텍스트, 함수에 대한 컨텍스트, eval() 함수로 실행되는 코드로 나뉜다.</p>
<p>여기서는 전역 코드에 대한 컨텍스트, 함수에 대한 컨텍스트로 살펴 보겠다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">console.log(<span class="string">"This is global context"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">ExContext1</span></span>()&#123;</span><br><span class="line">	console.log(<span class="string">"This is ExContext1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fucntion <span class="function"><span class="title">ExContext2</span></span>()&#123;</span><br><span class="line">	ExContext1();</span><br><span class="line">    console.log(<span class="string">"This is ExContext2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ExContext2();</span><br><span class="line"></span><br><span class="line">/*result</span><br><span class="line">This is global context</span><br><span class="line">This is ExContext1</span><br><span class="line">This is ExContext2</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>컨텍스트는 실행전 스택으로 쌓이고 후입선출로 하나씩 실행된다. 위 코드로 순서를 살펴보면,</p>
<p>가장 먼저 전역 컨텍스트가 만들어지고  ExContext2() 컨텍스트, ExContext1() 컨텍스트가 만들어 지고 나서 실행과 종료를 거친 후 전역 실행 컨텍스트의 실행이 완료되면 모든 실행이 끝난다. </p>
<p>실행 컨텍스트 고려한 코드 실행 과정은 다음과 같다.</p>
<p>1) 활성 객체 생성</p>
<p>2) arguments 객체 생성</p>
<p>3) 스코프 정보 생성</p>
<p>4) 변수 생성</p>
<p>5) this 바인딩</p>
<p>6) 코드실행</p>
<p>1) 활성 객체 생성</p>
<ul>
<li>실행에 필요한 메타정보를 담고 있는 객체로, 사용자가 정의한 변수 및 객체를 저장하며 새로 만들어진 컨텍스트로 접근 가능하게 되어 있다.</li>
</ul>
<p>2) arguments 객체 생성</p>
<ul>
<li>arguments 객체는 함수를 호출할 때 넘긴 인자들이 배열 형태로 저장된 객체를 의미하며, 1)에서 만들어진 활성 객체가 arguments 객체를 참조한다.</li>
</ul>
<p>구체적으로 살펴보기 위해 아래처럼 add함수에 arguments객체를 찍어보면,</p>
<img src="/gallery/book2-2-1.jpg" width="400px" />

<p>결과 값은 아래와 같다.</p>
<img src="/gallery/book2-2-2.jpg" width="400px" />

<p>arguments객체를 살펴보면, 전달된 인자 값, 인자의 개수(length), 함수의 참조값(callee)를 확인할 수 있다.</p>
<p>3) 스코프 정보 생성</p>
<ul>
<li>컨텍스트의 유효 범위를 나타내는 스코프 정보를 생성한다. 유효 범위 안에서 변수와 함수가 존재한다. 예를 들어 C언어의 경우 if문,for문, 함수 안에서 선언된 변수는 해당 블록 안에서만 유효하므로 밖에서 접근할 수 없다.</li>
</ul>
<p>그러나 자바스크립트의 경우 for문,if문은 유효 범위가 없고 함수만이 유효 범위를 갖는다. 함수의 유효범위는 [[scope]]프로퍼티에서 정의되는데 각각의 함수는 [[scope]]프로퍼티로 컨텍스트의 스코프 체인을 참조한다. 정리하면 실행 컨텍스트는 실행된 함수의 [[scope]]프로퍼티를 기반으로 새로운 스코프 체인을 만든다.  </p>
<p>4) 변수 생성</p>
<ul>
<li>코드 실행에 사용되는 변수의 생성이 이루어진다. 함수 인자의 경우 각각의 프로퍼티가 만들어지고 그 값이 할당된다. 만약 값이 없다면 undefined가 할당 된다.</li>
</ul>
<p>5) this 바인딩</p>
<ul>
<li>this 키워드를 사용하는 값이 할당된다. 여기서 this가 참조하는 객체가 없으면 전역 객체를 참조한다.</li>
</ul>
<p>6) 코드 실행</p>
<p>코드 실행 ~^_^</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-04-12T08:53:23.000Z" title="2020-04-12T08:53:23.000Z">2020-04-12</time><span class="level-item"><a class="link-muted" href="/categories/Book/">Book</a><span> / </span><a class="link-muted" href="/categories/Book/%EC%9D%B8%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">인사이드 자바스크립트</a></span><span class="level-item">8 minutes read (About 1195 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/04/12/book2-1/">JavaScript 클로저</a></h1><div class="content"><br/>

<h3 id="1-클로저-이해"><a href="#1-클로저-이해" class="headerlink" title="1. 클로저 이해"></a>1. 클로저 이해</h3><p>클로저는 함수 안에 있는 함수이다. 함수 안에 있어서 외부 함수, 내부 함수(클로저)라고 구분해서 부른다. 클로저의 특징은 외부 함수의 변수를 참조한다는 점이다. 예제를 한 번 살펴보자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">outerFunc</span></span>()&#123;</span><br><span class="line">	var x = 10;</span><br><span class="line">    var innerFunc = <span class="function"><span class="title">function</span></span>() &#123;console.log(x);&#125;</span><br><span class="line">    <span class="built_in">return</span> innerFunc;</span><br><span class="line">    </span><br><span class="line">var inner = outerFunc();</span><br><span class="line">inner()</span><br><span class="line">//result</span><br><span class="line">//10</span><br></pre></td></tr></table></figure>
<p>예제에서 innerFunc() 함수가 클로저이다. inner 변수 객체를 생성한 뒤, inner()를 실행하면 outerFunc()이 끝나고 나서 innerFunc()을 실행시킨다. innerFunc()은 외부 함수인 outerFunc의 변수 x를 참조하여 10을 출력했다. outerFunc() 함수가 끝났음에도 변수 x를 참조하여 10을 출력한 것이다. 어떻게 가능할까?</p>
<p>이 원리를 스코프 체인으로 이해해 보면, innerFunc()의 [[scope]]가 outerFunc의 변수객체와 전역 객체를 가지기 때문이다.</p>
<p>다시 말해, outerFunc 실행 컨텍스트는 사라졌지만 outerFunc 변수 객체는 innerFunc()의 [[scope]]에 계속 남아있으므로 x를 출력할 수 있는 것이다. 그래서 클로저를 이미 생명 주기가 끝난 외부함수의 변수를 참조하는 함수라고 정의할 수 있다. 그리고 x와 같이 클로저로 참조되는 외부 변수를 자유 변수라고 한다.</p>
<h3 id="2-클로저-활용"><a href="#2-클로저-활용" class="headerlink" title="2. 클로저 활용"></a>2. 클로저 활용</h3><p>클로저는 성능 저하나 메모리 부담의 원인이 되기도 한다. 그럼에도 불구하고 고급 기술에서는 클로저가 많이 쓰이기 때문에 제대로 이해하고 활용하는 것이 중요하다. 클로저의 활용 예제를 살펴보자.</p>
<p>2-1) 특정 함수에 사용자가 정의한 객체의 메서드 연결하기</p>
<p>먼저 예제 하나를 살펴보자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> HelloFunc(func)&#123;</span><br><span class="line">	this.greeting = <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HelloFunc.prototype.call = <span class="keyword">function</span>(func)&#123;</span><br><span class="line">	func? func(this.greeting) : this.func(this.greeting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var userFunc = <span class="keyword">function</span>(greeting)&#123;</span><br><span class="line">	console.log(greeting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var objHello = new HelloFunc();</span><br><span class="line">objHello.func = userFunc;</span><br><span class="line">objHello.call();</span><br><span class="line"></span><br><span class="line">//result</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<p>예제의 실행 코드부터 보면 HelloFunc() 생성자 함수로 objHello 변수 객체를 생성했다.</p>
<p>objHello에 func 프로퍼티를 userFunc으로 할당했다.</p>
<p>objHello의 call함수를 실행시키면, HelloFunc에는 call함수가 없으므로 HelloFunc  prototype객체에서 찾는데</p>
<p>call 메서드가 있으므로 실행시킨다. call 함수 호출 시, 매개 변수가 없으므로 this.func(this.greeting)이 실행되며 func 프로퍼티는</p>
<p>userFunc이라고 정의했으므로 userFunc(this.greeting)이 실행되고 결과적으로 hello가 출력된다.</p>
<p>여기서 call함수가 받는 인자는 greeting하나뿐이다. 만약 call() 함수 변경 없이 인자를 더 넣어서 호출하려면 어떻게 해야 할까?</p>
<p>아래 예제를 보자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> saySomething(obj, methodName, name)&#123;</span><br><span class="line">	<span class="built_in">return</span> (<span class="keyword">function</span>(greeting)&#123;</span><br><span class="line">    	<span class="built_in">return</span> obj[methodName](greeting, name);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> newObj(obj, name)&#123;</span><br><span class="line">	obj.func = saySomething(this, <span class="string">"who"</span>, name);</span><br><span class="line">    <span class="built_in">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newObj.prototype.who = <span class="keyword">function</span>(greeting, name)&#123;</span><br><span class="line">	console.log(greeting + <span class="string">" "</span> + (name || <span class="string">"everyone"</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = new newObj(objHello, <span class="string">"zzoon"</span>);</span><br><span class="line">obj1.call();</span><br></pre></td></tr></table></figure>
<p>이번에는 newObj() 생성자 함수로 obj1 변수 객체를 생성했다.</p>
<p>매개변수 값으로 objHello 객체와 “zzoon” 문자를 전달했다. 그러면 objHello 객체의 func 프로퍼티로 saySomething(this,”who”,name);에서 반환되는 함수를 참조한다.</p>
<p>saySomething의 매개변수 값을 살펴보면,</p>
<p>obj = this로, newObject 객체</p>
<p>methodName = “who”</p>
<p>name = “zzoon” 이 된다.</p>
<p>그리고 function(greeting){} 함수를 반환하는 데 이것이 HelloFunc 객체의 func으로 참조된다.</p>
<p>결과적으로 bj1.call()로 실행되는 것은 newObj.prototype.who()가 된다.</p>
<h3 id="3-클로저-주의사항"><a href="#3-클로저-주의사항" class="headerlink" title="3. 클로저 주의사항"></a>3. 클로저 주의사항</h3><p>3-1) 자유 변수 값은 변경 가능하다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> outerFunc(argNum)&#123;</span><br><span class="line">	var num = argNum;</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span>(x)&#123;</span><br><span class="line">    	num += x;</span><br><span class="line">        console.log(<span class="string">'num: '</span> + num);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> var exam = outerFunc(40);</span><br><span class="line"> exam(5);</span><br><span class="line"> exam(-10);</span><br><span class="line">     </span><br><span class="line">//result</span><br><span class="line">//45</span><br><span class="line">//35</span><br></pre></td></tr></table></figure>
<p>자유 변수 num의 값은 계속 변화하기 때문에 주의해야 한다.</p>
<p>3-2) 루프 안에서 사용할 때</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> countSeconds(howMany)&#123;</span><br><span class="line">	<span class="keyword">for</span>(var i = 1;i &lt;= howMany; i++)&#123;</span><br><span class="line">    	setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        	console.log(i);</span><br><span class="line">        &#125;, i * 1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">countSeconds(3);</span><br></pre></td></tr></table></figure>
<p>1, 2, 3을 1초 간격으로 출력하는 예제이지만 결과는 4가 연속 3번 1초 간격으로 출력된다.</p>
<p>왜냐하면 setTimeout 함수의 인자로 들어가는 함수는 자유 변수 i를 참조한다. 하지만 setTimeout함수가 실행되는 시점은 countSeconds() 함수의 실행이 종료된 이후이고, i 값은 이미 4가 된 상태이다 그러므로 모두 4를 출력하게 된다.</p>
<p>원하는 결과를 얻고 싶으면 아래와 같이 하면 된다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> countSeconds(howMany)&#123;</span><br><span class="line">	<span class="keyword">for</span> (var i = 1; i &lt;= howMany; i++) &#123;</span><br><span class="line">    	(<span class="keyword">function</span> (currentI) &#123; </span><br><span class="line">        	setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">            	console.log(currentI);</span><br><span class="line">            &#125;, currentI * 1000);</span><br><span class="line">        &#125;(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">countSeconds(3);</span><br></pre></td></tr></table></figure>
<p>구현 방법은 (function ( currentI){})라는 함수를 정의함과 동시에 바로 실행되는 즉시 실행 함수(immediate function)로 setTimeout을 감싸는 것이다. 루프 i 값을 currentI에 복사해 사용하면 원하는 결과를 얻을 수 있다.</p>
<p>끝 ^_^</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-04-11T06:42:10.000Z" title="2020-04-11T06:42:10.000Z">2020-04-11</time><span class="level-item"><a class="link-muted" href="/categories/Book/">Book</a><span> / </span><a class="link-muted" href="/categories/Book/%EB%B0%91%EB%B0%94%EB%8B%A5%EB%B6%80%ED%84%B0-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-%EB%94%A5%EB%9F%AC%EB%8B%9D/">밑바닥부터 시작하는 딥러닝</a></span><span class="level-item">10 minutes read (About 1512 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/04/11/book1-4/">CH5. 신경망 학습하기-2 (경사하강법)</a></h1><div class="content"><p>지난 챕터에서는 데이터를 예측하고 예측 값에 대한 손실함수 구하기를 살펴보았다. </p>
<p>지난 챕터 바로가기 : <a href="https://myphiloprogramming.tistory.com/22">https://myphiloprogramming.tistory.com/22</a></p>
<p>다음 순서를 계속 진행해보자.</p>
<ol start="4">
<li><p>경사하강법으로 가중치 값 개선하기</p></div><a class="article-more button is-small size-small" href="/2020/04/11/book1-4/#more">Read More</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-04-11T06:38:22.000Z" title="2020-04-11T06:38:22.000Z">2020-04-11</time><span class="level-item"><a class="link-muted" href="/categories/Book/">Book</a><span> / </span><a class="link-muted" href="/categories/Book/%EB%B0%91%EB%B0%94%EB%8B%A5%EB%B6%80%ED%84%B0-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-%EB%94%A5%EB%9F%AC%EB%8B%9D/">밑바닥부터 시작하는 딥러닝</a></span><span class="level-item">17 minutes read (About 2534 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/04/11/book1-3/">CH4. 신경망 학습하기-1 (손실함수, 교차엔트로피오차)</a></h1><div class="content"><p>이번 챕터에서는 신경망 학습 방법에 대해 알아본다. 우리는 “5”라고 쓴 손글씨 이미지를 입력하면 컴퓨터가 “5”라고 인식하는 모델을 만들고 싶다. 이 모델을 만들기 위해서 신경망을 학습시킬 것이다. (이를 모델링이라고도 한다.) 신경망은 학습을 통해 손글씨 값을 가장 잘 인식하는 가중치와 편향의 최적값을 찾아준다. 우리는 최적값을 가지고 숫자를 얼마나 잘 맞추는지 성능을 테스트 할 것이다.</p>
<p>우리가 사용할 데이터는 MNIST 패키지의 손글씨 이미지이다. 이미지는 다음과 같다.<br></div><a class="article-more button is-small size-small" href="/2020/04/11/book1-3/#more">Read More</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-04-11T06:35:37.000Z" title="2020-04-11T06:35:37.000Z">2020-04-11</time><span class="level-item"><a class="link-muted" href="/categories/Book/">Book</a><span> / </span><a class="link-muted" href="/categories/Book/%EB%B0%91%EB%B0%94%EB%8B%A5%EB%B6%80%ED%84%B0-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-%EB%94%A5%EB%9F%AC%EB%8B%9D/">밑바닥부터 시작하는 딥러닝</a></span><span class="level-item">10 minutes read (About 1470 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/04/11/book1-2/">CH3. 딥러닝의 시작2, 신경망 - 활성화 함수</a></h1><div class="content"><p>앞선 글에서 퍼셉트론, 가중치, 편향, 비선형, 다중퍼셉트론을 살펴보았다. 퍼셉트론 식을 구현하는 데 있어 가중치와 편향을 적절한 값으로 직접 설정했다. 그러나 층이 많아질수록 직접 설정할 수 없을 것이다. 신경망은 학습을 통해 가중치, 편향에 대한 적절한 값을 찾아준다.</p>
<h4 id="신경망"><a href="#신경망" class="headerlink" title="신경망"></a>신경망</h4> <img src="/gallery/book1-2-1.jpg" width="300px" />

<h4 id="신경망-네트워크"><a href="#신경망-네트워크" class="headerlink" title="신경망 네트워크"></a>신경망 네트워크</h4><p>신경망 네트워크는 입력층 - 은닉층 - 출력층으로 구성되는데, 은닉층의 경우 처리 과정을 확인할 수 없다.</p>
<p>신경망의 구조는 다층 퍼셉트론과 유사하다. 퍼셉트론에서 신경망으로 나아가 보자.</p></div><a class="article-more button is-small size-small" href="/2020/04/11/book1-2/#more">Read More</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-04-11T06:06:24.000Z" title="2020-04-11T06:06:24.000Z">2020-04-11</time><span class="level-item"><a class="link-muted" href="/categories/Book/">Book</a><span> / </span><a class="link-muted" href="/categories/Book/%EB%B0%91%EB%B0%94%EB%8B%A5%EB%B6%80%ED%84%B0-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-%EB%94%A5%EB%9F%AC%EB%8B%9D/">밑바닥부터 시작하는 딥러닝</a></span><span class="level-item">10 minutes read (About 1491 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/04/11/book1-1/">CH2.딥러닝의 시작, 퍼셉트</a></h1><div class="content"><p>퍼셉트론 알고리즘</p>
<p>퍼셉트론은 딥러닝의 기원이 되는 알고리즘으로, 다수의 신호를 입력으로 받아 처리한 후 하나의 신호를 출력한다. </p>
 <img src="/gallery/book1-1-1.jpg" width="400px" /></div><a class="article-more button is-small size-small" href="/2020/04/11/book1-1/#more">Read More</a></article></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3"><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Book/"><span class="level-start"><span class="level-item">Book</span></span><span class="level-end"><span class="level-item tag">8</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Book/%EB%B0%91%EB%B0%94%EB%8B%A5%EB%B6%80%ED%84%B0-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-%EB%94%A5%EB%9F%AC%EB%8B%9D/"><span class="level-start"><span class="level-item">밑바닥부터 시작하는 딥러닝</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Book/%EC%9D%B8%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"><span class="level-start"><span class="level-item">인사이드 자바스크립트</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">Recent</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-12T09:09:49.000Z">2020-04-12</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/12/book2-4/">Javascript 객체 지향[2] - class 상속/super/object 상속/__proto__ vs prototype</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Book/">Book</a> / <a class="link-muted" href="/categories/Book/%EC%9D%B8%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">인사이드 자바스크립트</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-12T09:06:33.000Z">2020-04-12</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/12/book2-3/">JavaScript 객체 지향[1] - this/constructor/prototype</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Book/">Book</a> / <a class="link-muted" href="/categories/Book/%EC%9D%B8%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">인사이드 자바스크립트</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-12T08:57:58.000Z">2020-04-12</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/12/book2-2/">JavaScript 실행 컨텍스트</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Book/">Book</a> / <a class="link-muted" href="/categories/Book/%EC%9D%B8%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">인사이드 자바스크립트</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-12T08:53:23.000Z">2020-04-12</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/12/book2-1/">JavaScript 클로저</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Book/">Book</a> / <a class="link-muted" href="/categories/Book/%EC%9D%B8%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">인사이드 자바스크립트</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-11T06:42:10.000Z">2020-04-11</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/11/book1-4/">CH5. 신경망 학습하기-2 (경사하강법)</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Book/">Book</a> / <a class="link-muted" href="/categories/Book/%EB%B0%91%EB%B0%94%EB%8B%A5%EB%B6%80%ED%84%B0-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-%EB%94%A5%EB%9F%AC%EB%8B%9D/">밑바닥부터 시작하는 딥러닝</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">April 2020</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/js/"><span class="tag">js</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/study/"><span class="tag">study</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/"><span class="tag">딥러닝</span><span class="tag is-grey-lightest">4</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="정지니 블로그" height="28"></a><p class="size-small"><span>&copy; 2020 Yejin Jeong</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://jyejin.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to Top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>