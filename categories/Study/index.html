<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Category: Study - 개발계발 블로그</title><meta property="og:type" content="blog"><meta property="og:title" content="개발계발 블로그"><meta property="og:url" content="https://jyejin.github.io/"><meta property="og:site_name" content="개발계발 블로그"><meta property="og:locale" content="en_US"><meta property="article:author" content="Yejin Jeong"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://jyejin.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jyejin.github.io"},"headline":"개발계발 블로그","image":["https://jyejin.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Yejin Jeong"},"description":""}</script><link rel="icon" href="/img/berry.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">개발계발</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">Categories</a></li><li class="is-active"><a href="#" aria-current="page">Study</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-23T05:54:03.000Z" title="2020-08-23T05:54:03.000Z">2020-08-23</time><span class="level-item"><a class="link-muted" href="/categories/Study/">Study</a><span> / </span><a class="link-muted" href="/categories/Study/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/">운영체제</a></span><span class="level-item">5 minutes read (About 791 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/23/study3/">IPC - 프로세스간 통신</a></h1><div class="content"><br/>
프로세스는 독립적으로 실행한다. 다른 프로세스의 데이터에 접근하려 해도 memory protection에서 접근하지 못하게 한다. 이처럼 독립적인 프로세스가 서로 통신하기 위한 방법이 무엇인지 살펴보자.

<h3 id="통신-방식"><a href="#통신-방식" class="headerlink" title="통신 방식"></a>통신 방식</h3><p>프로세스가 서로 통신하는 방식은 크게 2가지이다.</p>
<ol>
<li>Shared Memory </li>
<li>Message Passing</li>
</ol>
<h3 id="Shared-Memory"><a href="#Shared-Memory" class="headerlink" title="Shared Memory"></a>Shared Memory</h3><p>두 개 이상의 프로세스 들이 주소 공간의 일부를 공유하여 읽기 쓰기를 수행한다. 공유 메모리가 설정되면 커널의 관여없이 직접 읽고 쓸 수 있기 때문에 속도가 빠르다. 다른 프로세스의 변경 사항을 알기 위해 동기화가 필요하며, 한 번에 한 프로세스가 접근하는 접근 제어가 필요하다. 접근 제어 방식으로는 semaphore 등이 있다.</p>
<h3 id="Message-Passing"><a href="#Message-Passing" class="headerlink" title="Message Passing"></a>Message Passing</h3><p>한 프로세스에서 협력하는 다른 프로세스로 커널을 통해 메시지를 주고(send) 받는(receive) 방식이다. Message Passing 방식으로는 <code>PIPE, Message Queue, Socket, Signal</code> 등이 있다.</p>
<ul>
<li>파이프(PIPE)</li>
</ul>
<p>파이프는 통신을 위한 메모리 공간(버퍼)를 생성하고 버퍼를 통해 데이터를 전달하는데, 한 방향으로만 전달 가능하다. 다시 말해, 한 쪽 프로세스(A)는 보내기만 다른 한 쪽(B)은 받기만 가능한 것이다. 데이터를 서로 주고 받기 위해서는 A → B방향 파이프, B → A 방향 파이프 2개 연결해야 한다. 또한 여러 개 프로세스가 접근하지 못한다. 그렇기 때문에 프로세스가 많을수록 파이프 수도 증가하며 메모리 공간을 많이 차지하게 된다.</p>
<p>파이프는 Anonymous PIPE와 Named PIPE로 나뉜다.</p>
<ol>
<li>Anonymous PIPE</li>
</ol>
<p>관련없는 외부 프로세스에서는 사용하지 못하는, 부모 프로세스와 자식 프로세스 간에 사용하는 PIPE</p>
<ol start="2">
<li>Named PIPE</li>
</ol>
<p>외부 프로세스에 간 통신에서 사용하는 PIPE</p>
<ul>
<li>메세지 큐(Message Queue)</li>
</ul>
<p>고정된 크기의 메시지를 연결 리스트를 이용하여 통신하는 방법이다. Message Queue에는 여러 프로세스가 접근 가능하며 동기화가 필요하다. </p>
<ul>
<li>소켓(Socket)</li>
</ul>
<p>상대 프로세스의 소켓으로 통신하며, 포트 번호를 통해 소켓을 찾아간다. 다른 IPC는 로컬에서만 사용 가능한 반면, 소켓은 로컬과 리모트 서버 모두 통신 가능하다.</p>
<ul>
<li>시그널(Signal)</li>
</ul>
<p>특정 이벤트가 발생했을 때 프로세스에게 시그널을 전달할 수 있다. 예를 들어, 자식 프로세스가 종료되었거나 오류가 발생했을 때, 인터럽트가 발생했을 때 그 정보를 알리는 시그널을 전달한다. 시그널은 여러 종류가 있으며 시그널 별로 번호가 붙어있다. 시그널 핸들러를 통해 특정 시그널에 대한 함수를 실행할 수 있다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-17T05:55:44.000Z" title="2020-08-17T05:55:44.000Z">2020-08-17</time><span class="level-item"><a class="link-muted" href="/categories/Study/">Study</a><span> / </span><a class="link-muted" href="/categories/Study/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/">운영체제</a></span><span class="level-item">10 minutes read (About 1519 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/17/study4/">메모리 관리</a></h1><div class="content"><br/>

<h3 id="메모리-관리"><a href="#메모리-관리" class="headerlink" title="메모리 관리?"></a>메모리 관리?</h3><p>프로세스를 실행할 때는 프로그램이 메모리에 적재 되어야 한다. 운영체제는 프로세스를 다중으로 운영하므로 메모리를 어떻게 사용하고, 배치할지, 메모리가 부족할 때는 어떻게 해야 하는지 등의 관리가 필요해진다.</p>
<h3 id="주소-지정-시점"><a href="#주소-지정-시점" class="headerlink" title="주소 지정 시점"></a>주소 지정 시점</h3><p>메모리 주소는 논리적 주소와 물리적 주소로 나뉜다. 논리적 주소는 프로세스 실행 시 생성되는 독자적인 가상의 주소 공간이며 물리적 주소는 실제 메모리 상의 위치를 의미한다. CPU가 논리적 주소를 통해 물리적 주소로 접근할 수 있어야 하는데, 논리적 주소를 물리적 주소로 매핑하는 것을 바인딩이라고 한다.</p>
<p>주소가 지정 되는 시점, 바인딩 되는 시점은 3가지로 나뉜다. </p>
<ul>
<li><p>컴파일 시점 바인딩</p>
<p>  프로그램이 메모리의 어느 위치에 적재될 지 컴파일 시점에 알 수 있다면 메모리 물리 주소를 지정할 수 있다.</p>
</li>
<li><p>로드 시점 바인딩</p>
<p>  프로그램의 실행이 시작될 때 물리 주소가 결정되는 방식으로 프로그램이 종료될 때까지 물리적 메모리 상의 위치가 고정된다.</p>
</li>
<li><p>실행 시점 바인딩</p>
<p>  프로그램 실행 중에 메모리 주소가 변경되는 방식이다. 하드웨어가 주소를 변경 해주는 하드웨어의 지원이 필요하다. ⇒ MMU</p>
</li>
</ul>
<p>** <strong>MMU</strong></p>
<p>논리 주소를 물리 주소로 변환하는 하드웨어이다. CPU에서 특정 논리 주소 위치에 저장된 데이터를 요청할 때 MMU가 자동으로 물리적 주소로 변환하여 해당 위치에 접근하는 것을 지원한다. 프로그램의 주소 공간이 메모리의 연속적인 공간에 적재되어 있다고 가정한다. </p>
<h3 id="메모리-할당법"><a href="#메모리-할당법" class="headerlink" title="메모리 할당법"></a>메모리 할당법</h3><ol>
<li>연속 할당</li>
</ol>
<p>메모리를 다수의 메모리로 분할하고 각 프로세스는 메모리의 연속적인 공간에 적재된다. 메모리 분할 방식으로는 고정 분할 방식과 가변 분할 방식이 있다. </p>
<ul>
<li>고정 분할 방식<ul>
<li>고정된 크기의 분할로 미리 나눔</li>
</ul>
</li>
<li>가변 분할 방식<ul>
<li>최초 적합 : 첫번째로 찾은 공간에 할당하는 방법, 시간 최적화</li>
<li>최적 적합 : 모든 공간 중에 수용 가능한 가장 작은 곳을 선택, 공간을 최적화</li>
<li>최악 적합 : 모든 공간 중에 수용 가능한 가장 큰 곳을 선택, 공간 낭비 발생</li>
</ul>
</li>
</ul>
<p>프로세스 실행 시, 프로세스에 필요한 메모리보다 같거나 큰 메모리 공간을 찾아 프로세스가 사용할 수 있도록 배정한다. </p>
<p>연속 할당에는 단편화라는 문제가 발생하는데, 단편화란 프로세스의 반복적인 실행과 종료로 인해 복수의 사용하지 않는 메모리 공간, 즉 구멍이 메모리 상에 발생하는 것을 의미한다. 여유 메모리 공간이 하나의 할당 요청을 만족시키기에는 충분하지만 구멍이 연속적이지 않아 할당할 수 없는 문제를 외부 단편화라고 한다. 그리고 할당된 메모리가 요청한 메모리 크기보다 커 남는 공간을 내부 단편화라고 한다. 이 문제를 해결하기 위해 남은 구멍들을 합치는 압축 기능을 사용하여 연속적인 메모리 공간을 만들고 프로세스에 할당한다.</p>
<ol start="2">
<li>불연속 할당</li>
</ol>
<p>연속적인 메모리 공간이 아닌 불연속적인 메모리 공간을 사용함으로써 압축에 드는 시간을 없앤다. 불연속 할당 기법으로는 페이징 기법과 세그먼트 기법이 있다.</p>
<ul>
<li><p>페이징 기법</p>
<p>  프로세스의 주소 공간을 동일한 크기의 페이지 단위로 나누어 불연속적인 메모리 공간에 할당하는 방식이다. 물리적 메모리를 프로세스의 페이지 크기와 동일한 크기로 나누고 메모리에 페이지를 할당한다. 프로세스의 몇번째 페이지가 물리적 메모리에 몇번째 위치에 들어있다는 정보가 필요한데, 이 정보를 <code>페이지 테이블</code>이 갖고 있다. 페이지 테이블을 사용하여 논리주소를 물리주소로 매핑한다.</p>
<p>   각 프로세스의 메모리 영역 전체를 물리적 공간에 적재할 필요없으며 일부는 backing store에 일시적으로 보관하는 것이 가능하다. </p>
<p>  페이지 크기에 맞춰 메모리를 나누기 때문에 외부 단편화 문제가 발생하지 않지만 내부 단편화는 발생한다.</p>
</li>
<li><p>세그먼트 기법</p>
<p>  페이징 기법에서는 가상 메모리를 같은 크기의 페이지로 분리했다면, 세그먼트 기법은 서로 다른 크기의 논리적 단위인 세그먼트로 분할하고 메모리를  할당하며 주소를 반환한다. 세그먼트들은 크기가 각각 다르며 연속적인 메모리 공간에 저장되어 있다. 세그먼트 가상의 주소는 세그먼트 번호와 블록 내 세그먼트의 길이를 나타낸다. 페이징 기법에는 페이징 테이블이 있는 것처럼 세그먼트 기법에는 세그먼트 테이블이 있어 실제 주소를 매핑하는 저장 정보를 포함하고 있다. 세그먼트 테이블에는 항목별로 Base(세그먼트 시작 주소)와 Limit(세그먼트 길이)의 정보를 가지고 있다.</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-09T08:30:05.000Z" title="2020-08-09T08:30:05.000Z">2020-08-09</time><span class="level-item"><a class="link-muted" href="/categories/Study/">Study</a></span><span class="level-item">9 minutes read (About 1283 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/09/project-3/">pytest 사용기 - fixture, scope</a></h1><div class="content"><br/>
파이썬에서 제공하는 테스팅 모듈로는 unittest, pytest가 유명한데, 둘 중 어느걸 사용해 볼까 하다가 pytest가 간단해 보여서 pytest로 작업을 진행했습니다. 빠른 진행을 위해서는 테스팅 모듈이 간편한게 좋을 것 같다는 생각이 들었기 때문입니다. pytest 어떻게 사용했는지 살펴보겠습니다.

<h3 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h3><p>pytest는 <code>pip</code> 로 설치하며 기초 설명은 <a href="https://docs.pytest.org/en/latest/index.html">공식 홈페이지</a>에서 확인 가능합니다.</p>
<hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pytest</span><br></pre></td></tr></table></figure>

<h3 id="프로젝트-구조"><a href="#프로젝트-구조" class="headerlink" title="프로젝트 구조"></a>프로젝트 구조</h3><hr>
<p>테스트 코드를 작성한 <a href="https://github.com/Jyejin/logparser">프로젝트</a>의 구조는 다음과 같습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── logparser</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── models.py</span><br><span class="line">│   └── parser.py</span><br><span class="line">├── logs</span><br><span class="line">│   ├── elb1.log.gz</span><br><span class="line">│   ├── elb2.log.gz</span><br><span class="line">├── pytest.ini</span><br><span class="line">└── test</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    ├── conftest.py</span><br><span class="line">    ├── logs&#x2F;</span><br><span class="line">    └── test_parser.py</span><br></pre></td></tr></table></figure>

<p>pytest를 위해 작성한 파일은 <code>pytest.ini</code>와 test폴더 하위의 파일들입니다. 먼저, <code>pytest.ini</code>에는 테스트에 사용할 파일과 테스트 옵션을 추가합니다. 일반적으로 test_*.py 또는 *_test.py를 테스트 파일로 인식하지만 직접 지정해줄 수도 있습니다. 파일이 여러 개인 경우 스페이스로 구분합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[pytest]</span><br><span class="line">python_files &#x3D; test_parser.py test_*.py</span><br></pre></td></tr></table></figure>

<p>테스트는 <code>pytest</code> 명령어를 사용해 실행합니다. 실행하는 경로에 상관없이 pytest용 파일을 찾아 실행합니다. <code>q</code>옵션을 사용하면 로그를 간략하게 볼 수 있습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(venv) yejinui-MacBook-Pro:logparser yejin$ pytest -q</span><br><span class="line">.....                                                                                                                                                                     [100%]</span><br><span class="line">5 passed in 31.78s</span><br></pre></td></tr></table></figure>

<h3 id="테스트-코드-작성"><a href="#테스트-코드-작성" class="headerlink" title="테스트 코드 작성"></a>테스트 코드 작성</h3><p>테스트 함수에는 아래와 같이 함수명에 접두사로 <code>test_</code> 를 붙여야 합니다. 접두사가 없으면 그 함수는 실행하지 않고 넘어갑니다. count 함수와 sequence 함수를 테스트 하기 위해 각각 <code>test_count</code>, <code>test_sequnce</code>함수를 만들었습니다. <code>test_count</code>는 로그 수가 맞는지를 확인하고 <code>test_sequence</code>는 ‘type’ 별 집계가 일치하는지 확인합니다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#test_parser.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_count</span><span class="params">()</span>:</span></span><br><span class="line">    logs = log_parser(get_test_log)</span><br><span class="line">    <span class="keyword">assert</span> count(logs) == <span class="number">87060</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_sequence</span><span class="params">()</span>:</span></span><br><span class="line">    logs = log_parser(get_test_log)</span><br><span class="line">    <span class="keyword">assert</span> sequence(logs, <span class="string">'type'</span>, reverse=<span class="literal">True</span>) == [</span><br><span class="line">        (<span class="string">'http'</span>, <span class="number">82719</span>),</span><br><span class="line">        (<span class="string">'h2'</span>, <span class="number">3398</span>),</span><br><span class="line">        (<span class="string">'https'</span>, <span class="number">943</span>)</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<p>두 함수에서는 공통적으로 log_parser()함수를 사용해 로그를 읽어옵니다. 예시 이외에도 로그를 읽어 오는 테스트가 더 있어 클래스를 정의하는 방식으로 변경하였습니다. self.logs를 사용하는 방식으로 코드를 수정했습니다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestParserClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, get_test_log)</span>:</span></span><br><span class="line">        self.logs = list(log_parser(get_test_log))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_count</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> count(self.logs) == <span class="number">87060</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_sequence</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> sequence(self.logs, <span class="string">'type'</span>, reverse=<span class="literal">True</span>) == [</span><br><span class="line">            (<span class="string">'http'</span>, <span class="number">82719</span>),</span><br><span class="line">            (<span class="string">'h2'</span>, <span class="number">3398</span>),</span><br><span class="line">            (<span class="string">'https'</span>, <span class="number">943</span>)</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure>

<p>그런데 에러가 발생했습니다. 클래스에 <code>__init__</code>를 정의한 것이 문제가 되었습니다. <a href="https://docs.pytest.org/en/stable/warnings.html#internal-pytest-warnings">공식 홈페이지</a>를 확인해보니 <code>__init__</code>를 정의하는 경우 클래스가 인스턴스화 되지 않는다고 하네요.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(venv) yejinui-MacBook-Pro:logparser yejin$ pytest -q</span><br><span class="line">=============================================================================== warnings summary ================================================================================</span><br><span class="line">test/test_parser.py:<span class="number">9</span></span><br><span class="line">  /Users/yejin/Sites/project/logparser/test/test_parser.py:<span class="number">9</span>: PytestCollectionWarning: cannot collect test <span class="class"><span class="keyword">class</span> '<span class="title">TestParserClass</span>' <span class="title">because</span> <span class="title">it</span> <span class="title">has</span> <span class="title">a</span> <span class="title">__init__</span> <span class="title">constructor</span> <span class="params">(from: test/test_parser.py)</span></span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">TestParserClass</span>:</span></span><br><span class="line"></span><br><span class="line">-- Docs: https://docs.pytest.org/en/stable/warnings.html</span><br><span class="line"><span class="number">1</span> passed, <span class="number">1</span> warning <span class="keyword">in</span> <span class="number">0.03</span>s</span><br></pre></td></tr></table></figure>

<p>그래서 <code>fixture</code>를 사용했습니다. fixture란, 테스트 시 사용하는 함수들을 미리 정의하는 기능입니다.</p>
<p><code>fixture</code>함수는 test/conftest.py에 작성합니다. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#test/conftest.py</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture(scope="module")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_log_parse</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> list(log_parser(get_log(<span class="string">'./logs/'</span>)))</span><br></pre></td></tr></table></figure>

<p>test_ 함수에서 사용할 때에는 따로 conftest를 임포트할 필요없이 매개변수로 지정하기만 하면됩니다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#test_parser.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_count</span><span class="params">(test_log_parse)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> count(test_log_parse) == <span class="number">87060</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_sequence</span><span class="params">(test_log_parse)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> sequence(test_log_parse, <span class="string">'type'</span>, reverse=<span class="literal">True</span>) == [</span><br><span class="line">        (<span class="string">'http'</span>, <span class="number">82719</span>),</span><br><span class="line">        (<span class="string">'h2'</span>, <span class="number">3398</span>),</span><br><span class="line">        (<span class="string">'https'</span>, <span class="number">943</span>)</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<p>굳이 fixture를 사용하지 않고 test_log_parse 함수를 만들어도 되는게 아닌가 생각할 수도 있습니다. 그렇게도 가능합니다. 그러나 깨끗한 테스트 코드를 위해 변하지 않는 기능은 한 곳에 넣어두고 자주 변경되며 확장할 기능을 만들도록 하는 것이 관리에 좋아 보입니다. 클래스 상속 개념처럼요🙂 그리고 무엇보다도 fixture를 사용하면 fixture가 제공하는 부가 옵션들을 사용할 수 있습니다. 여기서는  <code>scope</code>를 사용했습니다.</p>
<p>scope를 사용해 fixture를 모듈, 클래스, 세션 단위로 공유합니다. 다시 말해, test_ 함수를 실행할 때마다 fixture함수를 재호출하지 않고 사용할 수 있다는 것입니다. scope를 module 단위로 지정했더니, test_log_parse 한 번 호출 후 계속 재사용하기 때문에 아래와 같이 실행 시간이 단축됩니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;scope 사용</span><br><span class="line">(venv) yejinui-MacBook-Pro:logparser yejin$ pytest -q</span><br><span class="line">.....                                                                                                                                                                     [100%]</span><br><span class="line">5 passed in 34.24s</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;scope 미사용</span><br><span class="line">(venv) yejinui-MacBook-Pro:logparser yejin$ pytest -q</span><br><span class="line">.....                                                                                                                                                                     [100%]</span><br><span class="line">5 passed in 131.13s (0:02:11)</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-07-04T05:14:56.000Z" title="2020-07-04T05:14:56.000Z">2020-07-04</time><span class="level-item"><a class="link-muted" href="/categories/Study/">Study</a><span> / </span><a class="link-muted" href="/categories/Study/ETC/">ETC</a></span><span class="level-item">10 minutes read (About 1475 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/07/04/study2-2/">&lt;클린 코드&gt; 좋았던 내용 기록하기(7-12장)</a></h1><div class="content"><br/>

<h3 id="7장"><a href="#7장" class="headerlink" title="7장"></a>7장</h3><p>오류 처리를 프로그램 논리와 분리하자. 프로그램 논리와 분리하면 독립적인 추론이 가능해지며 코드 유지보수성이 높아진다.</p>
<h3 id="오류-코드보다-예외를-사용해라"><a href="#오류-코드보다-예외를-사용해라" class="headerlink" title="오류 코드보다 예외를 사용해라"></a>오류 코드보다 예외를 사용해라</h3><p>If 처리보다 오류가 발생하면 예외를 던지는 편이 코드도 간결하고 읽기쉽다.</p>
<h3 id="감싸기-기법"><a href="#감싸기-기법" class="headerlink" title="감싸기 기법"></a>감싸기 기법</h3><p>외부 api를 사용할 때는 감싸기 기법이 최선이다.</p>
<p>LocalPort클래스에서 ACMEPort 클래스를 감싸고 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalPort</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ACMEPort innerPort;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LocalPort</span><span class="params">(<span class="keyword">int</span> portNumber)</span></span>&#123;</span><br><span class="line">		innerPort = <span class="keyword">new</span> ACMEPort(portnumber);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			innerPort.open();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(DeviceResponseException e)&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> PortDeviceFailure(e);</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>외부 api를 감싸면 외부 라이브러리와 프로그램 사이에서 의존성이 크게 줄어든다. 나중에 다른 라이브러리로 갈아타도 비용이 적다. 또한 감싸기 클래스에서 외부 api를 호출하는 대신 테스트 코드를 넣어주는 방법으로 프로그램을 테스트하기 쉬어진다.</p>
<h3 id="9장-단위-테스트"><a href="#9장-단위-테스트" class="headerlink" title="9장 단위 테스트"></a>9장 단위 테스트</h3><h3 id="TDD법칙-3가지"><a href="#TDD법칙-3가지" class="headerlink" title="TDD법칙 3가지"></a>TDD법칙 3가지</h3><ol>
<li>실패하는 단위테스트를 작성할 때까지 실제 코드를 작성하지 않는다.</li>
<li>컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.</li>
<li>현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.</li>
</ol>
<h3 id="깨끗한-테스트코드-유지하기"><a href="#깨끗한-테스트코드-유지하기" class="headerlink" title="깨끗한 테스트코드 유지하기"></a>깨끗한 테스트코드 유지하기</h3><p>테스트 코드는 실제코드 못지 않게 중요하다. 실제 코드 못지않게 깨끗하게 짜야한다.</p>
<p>코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 바로 단위테스트이다. 왜냐하면 테스트 케이스가 있으면 변경에 부담이 없기 때문이다.</p>
<h3 id="깨끗한-테스트-코드"><a href="#깨끗한-테스트-코드" class="headerlink" title="깨끗한 테스트 코드"></a>깨끗한 테스트 코드</h3><p>깨끗한 테스트 코드를 만들때에는 가독성이 제일 중요하다.</p>
<p>중복되는 코드를 삭제하고 의도를 흐리지 않아야 한다.</p>
<p>테스트는 BUILD-OPERATE-CHECK 패턴으로 나눠진다. 첫 부분은 테스트 자료를 만든다. 두 번째는 테스트 자료를 조작하며, 세번 째 부분은 조작한 결과가 올바른지 확인한다.</p>
<h3 id="이중-표준"><a href="#이중-표준" class="headerlink" title="이중 표준"></a>이중 표준</h3><p>테스트 코드는 단순하고 간결하고 표현력이 풍부해야 하지만 실제 코드만큼 효율적일 필요는 없다.</p>
<h3 id="테스트-당-assert-하나"><a href="#테스트-당-assert-하나" class="headerlink" title="테스트 당 assert 하나"></a>테스트 당 assert 하나</h3><p>한 함수에서 assert문을 적용하려 하다보면, 중복되는 코드가 많아진다. 이때는 <code>TEMPLATE METHOD</code> 패턴을 사용하면 중복을 제거할 수 있다. </p>
<p> ** template method : 변하지 않는 기능은 슈퍼 클래스에 넣어두고 자주 변경되며 확장할 기능은 서브 클래스에 만들도록 한다.</p>
<p>테스트 당 assert 함수 한개가 어렵다면, 테스트 함수마다 한 개념만 테스트하라는 규칙을 지키는 방법도 있겠다.</p>
<p>FIRST</p>
<p>빠르게, 독립적으로, 반복가능하게, 자가검증하는(return bool), 적시에(실제 코드 이전에 작성)</p>
<h3 id="10장-클래스"><a href="#10장-클래스" class="headerlink" title="10장 클래스"></a>10장 클래스</h3><h3 id="클래스-체계"><a href="#클래스-체계" class="headerlink" title="클래스 체계"></a>클래스 체계</h3><p>Static public 상수,</p>
<p>Private 변수,</p>
<p>비공개 인스턴스 변수,</p>
<p>공개 함수,</p>
<p>바로 위 공개 함수가 호출하는 비공개 함수</p>
<h3 id="클래스는-작아야-한다"><a href="#클래스는-작아야-한다" class="headerlink" title="클래스는 작아야 한다!"></a>클래스는 작아야 한다!</h3><h3 id="단일-책임-원칙-srp"><a href="#단일-책임-원칙-srp" class="headerlink" title="단일 책임 원칙(srp)"></a>단일 책임 원칙(srp)</h3><p>단일 책임 원칙은 클래스나 모듈을 변경할 이유가 하나뿐이어야 한다는 원칙이다.</p>
<p>큰 클래스 몇개가 아니라 작은 클래스 여럿으로 이뤄진 시스템이 더 바람직하다. 작은 클래스는 각자 맡은 책임이 하나이며 다른 작은 클래스와 협력해 싯스템에 필요한 동작을 수행한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperDashboard</span> <span class="keyword">extends</span> <span class="title">JFrame</span> <span class="title">impletements</span> <span class="title">MetaDataUser</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Component <span class="title">getLastFocusedComponent</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastFocused</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMajorVersionNumber</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinorVersionNumber</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBuildNumber</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="응집도"><a href="#응집도" class="headerlink" title="응집도"></a>응집도</h3><p>클래스는 인스턴스 변수 수가 작아야 한다. 각 클래스 메서드는 클래스 인스턴스 변수를 하나 이상 사용해야 한다. 메서드가 변수를 더 많이 사용할수록 메서드와 클래스는 응집도가 높다.</p>
<p>응집도가 높다는 말은 메서드와 변수가 서로 의존하며 논리적인 단위로 묶여있음을 의미한다.</p>
<h3 id="클래스가-응집력을-잃는다면-쪼개라"><a href="#클래스가-응집력을-잃는다면-쪼개라" class="headerlink" title="클래스가 응집력을 잃는다면 쪼개라!"></a>클래스가 응집력을 잃는다면 쪼개라!</h3><p>메서드가 많아지고 인스턴스 변수가 많아지면, 응집도를 고려하여 변수와 메서드를 적절히 분리해 새로운 두세개 클래스로 쪼개야한다. 다시 말해, 응집도를 유지하면 작은 클래스 여럿이 나오게 된다.</p>
<h3 id="변경하기-쉬운-클래스"><a href="#변경하기-쉬운-클래스" class="headerlink" title="변경하기 쉬운 클래스"></a>변경하기 쉬운 클래스</h3><p>깨끗한 시스템은 클래스를 체계적으로 정리해 변경에 수반하는 위험을 낮춘다.</p>
<h3 id="변경으로부터-격리"><a href="#변경으로부터-격리" class="headerlink" title="변경으로부터 격리"></a>변경으로부터 격리</h3><p>외부 api를 사용해 코드를 작성하는데, 5분마다 api 값이 달라진다면 테스트 코드를 짜기란 쉽지 않다. 이럴 때에는, 함수 내에서 api를 직접 호출하는 대신 클래스로 따로 뺀 후 mocking을 사용해 테스트한다. 이처럼 결합도를 낮추면 유연성과 재사용성도 더욱 높아지며 DIP를 따르는 클래스가 나온다.</p>
<h3 id="12장-창발성"><a href="#12장-창발성" class="headerlink" title="12장 창발성"></a>12장 창발성</h3><p>단순한 설계 규칙은 설계 품질을 높여주며, 다음 규칙을 따르면 설계가 단순하다고 말한다.</p>
<ul>
<li>모든 테스트를 실행한다.</li>
<li>중복을 없앤다.</li>
<li>프로그래머 의도를 표현한다.</li>
<li>클래스 수와 메서드 수를 최소로 줄인다.</li>
</ul>
<p><strong>&lt; Clean Code &gt; 도서의 내용을 공부하며 요약 정리하였습니다.</strong></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-06-14T06:30:33.000Z" title="2020-06-14T06:30:33.000Z">2020-06-14</time><span class="level-item"><a class="link-muted" href="/categories/Study/">Study</a><span> / </span><a class="link-muted" href="/categories/Study/ETC/">ETC</a></span><span class="level-item">13 minutes read (About 1927 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/14/study2-1/">&lt;클린 코드&gt; 좋았던 내용 기록하기(1-3장)</a></h1><div class="content"><br/>

<h2 id="1장-깨끗한-코드"><a href="#1장-깨끗한-코드" class="headerlink" title="1장. 깨끗한 코드"></a>1장. 깨끗한 코드</h2><p>시간에 쫓겨서 급하게 나쁜 코드를 짠 적이 있을 것이다. 나중에 다시 짜야지라는 생각으로 급하게 코드를 짜고는 하지만 나중은 오지 않는다.</p>
<p>깨끗한 코드를 짜기 위해서는 코드 감각이 필요하다. 깨끗한 코드란 그 정의도 다양하지만 대충의 의견은 다음과 같다.</p>
<ol>
<li>논리가 간단해서 버그가 숨어들지 한다. 한 가지를 제대로 한다.</li>
<li>잘 쓴 문장처럼 읽힌다. </li>
<li>작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다.</li>
<li>테스트 코드가 없는 코드는 깨끗한 코드가 아니다.</li>
<li>중복을 피해야 한다.</li>
</ol>
<p>정리 : 중복을 피하라. 한 기능만 수행해라. 제대로 표현하라. 작게 추상화하라</p>
<h2 id="2장-의미있는-이름"><a href="#2장-의미있는-이름" class="headerlink" title="2장. 의미있는 이름"></a>2장. 의미있는 이름</h2><h3 id="의도를-분명하게-밝혀라"><a href="#의도를-분명하게-밝혀라" class="headerlink" title="의도를 분명하게 밝혀라"></a>의도를 분명하게 밝혀라</h3><ul>
<li>Int d; ⇒ int daysSincedCreation;</li>
<li>List ⇒ group, bunch</li>
</ul>
<h3 id="의미-있게-구분하라"><a href="#의미-있게-구분하라" class="headerlink" title="의미 있게 구분하라"></a>의미 있게 구분하라</h3><ul>
<li>차이를 알도록 이름을 지어야 한다.<ul>
<li>나쁜 예시 : GetActiveAccount(), GetActiveAccounts(), GetActiveAccountInfo()</li>
<li>나쁜 예시2 : CustomerInfo/customer, accountdata/account</li>
</ul>
</li>
<li>문자 하나만 사용하는 변수 이름은 문제가 있다.<ul>
<li>루프에서 반복 횟수를 세는 i,j,k는 괜찮다(l은 절대 안됨). 단, 루프 범위가 아주 작고 다른 이름과 충돌하지 않을 때만 괜찮다.</li>
</ul>
</li>
</ul>
<h3 id="해법-영역에서-가져온-이름을-사용하라"><a href="#해법-영역에서-가져온-이름을-사용하라" class="headerlink" title="해법 영역에서 가져온 이름을 사용하라"></a>해법 영역에서 가져온 이름을 사용하라</h3><p> 코드를 읽는 사람도 프로그래머이다. 그러므로 전산용어, 알고리즘 이름 등을 사용해도 괜찮다. 모든 명칭을 문제 영역에서 가져올 것이 아니라, 기술 개념에는 기술 이름을 가져오는 것이 가장 적합한 선택이다.  적합한 프로그래머 용어가 없을 때, 문제 영역에서 이름을 가져온다.</p>
<p>** 문제 영역이란, 코드를 짜려는 프로젝트에 쓰이는 명칭 들을 말하는 것으로 보임. 예를 들면, 금리 관련 프로젝트에서는 정액제, 만기 등을 사용하는 것.</p>
<h3 id="의미있는-맥락을-추가하라"><a href="#의미있는-맥락을-추가하라" class="headerlink" title="의미있는 맥락을 추가하라"></a>의미있는 맥락을 추가하라</h3><p>예를 들어, firstName, city, street, houseNumber, state, zipcode라는 변수가 있다. 변수를 전체적으로 보면 주소라는 사실을 알 수 있지만 state변수 하나만으로는 쉽게 알아채기 어렵다. 이럴 때는 addr이라는 접두어를 추가해 addrFirstName, addrLastName, addrState라 쓰면 맥락이 좀 더 분명해진다.</p>
<h2 id="3장-함수"><a href="#3장-함수" class="headerlink" title="3장. 함수"></a>3장. 함수</h2><h3 id="작게-만들어라"><a href="#작게-만들어라" class="headerlink" title="작게 만들어라!"></a>작게 만들어라!</h3><p>함수를 만드는 첫째 규칙은 ‘작게!’다. 둘 째 규칙은 ‘더 작게!’이다. 함수는 100줄을 넘어서는 안된다. 20줄도 길다…</p>
<p>다시 말해, if문/else문/while문 등에 들어가는 블록은 한 줄이어야 한다는 의미이다. 대개 거기서 함수를 호출한다.</p>
<h3 id="한-가지만-해라"><a href="#한-가지만-해라" class="headerlink" title="한 가지만 해라!"></a>한 가지만 해라!</h3><p>충고 : <strong>함수는 한 가지를 해야 한다. 그 한가지를 잘해야 한다. 그 한가지 만을 해야한다.</strong></p>
<p>이 충고의 문제는 한 가지가 무엇인지 알기가 어렵다는 점이다. </p>
<p>3-3을 보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3-3</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">renderPageWithSetupsAndTeardowns</span><span class="params">(PageData PageData,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">boolean</span> isSuite)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(isTestPage(pageData))</span><br><span class="line">		includeSetupAndTeardownPages(pageData, isSuite);</span><br><span class="line">	<span class="keyword">return</span> pageData.getHtml()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>목록 3-3은 한가지만 하는가? 세가지를 한다고 주장할 수도 있다.</p>
<ol>
<li>페이지가 테스트페이지인지 판단한다.</li>
<li>그렇다면 설정 페이지와 해제 페이지를 넣는다.</li>
<li>페이지를 HTML로 렌더링한다.</li>
</ol>
<p>위에서 언급하는 세 단계는 지정된 함수 이름 아래에서 추상화 수준이 하나다. 함수는 간단한 <code>TO</code>문단으로 기술할 수 있다.</p>
<p>** <code>TO</code> : LOGO 언어에서 사용하는 함수 선언 방식으로, 파이썬이나 루비의 <code>def</code>와 같다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TO RenderPageWithSetupAndTeardowns, </span><br><span class="line">페이지가 테스트 페이지인지 확인한 후 테스트 페이지라면 설정 페이지와 해제 페이지를 넣는다.</span><br><span class="line">테스트 페이지든 아니든 페이지를 HTML로 렌더링한다.</span><br></pre></td></tr></table></figure>

<p>정리하면, 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한가지 작업만 한다고 볼 수 있다. 또 다른 방법은, 단순히 다른 표현이 아니라 의미있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러작업을 하는 셈이다.</p>
<h3 id="함수-당-추상화-수준은-하나로-⭐"><a href="#함수-당-추상화-수준은-하나로-⭐" class="headerlink" title="함수 당 추상화 수준은 하나로!⭐"></a>함수 당 추상화 수준은 하나로!⭐</h3><p>함수가 확실히 한 가지 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야한다. 함수 호출 <code>getHtml()</code> 은 추상화 수준이 높다. 그리고 모듈을 사용한 변수 선언(?) <code>String pagePathName = PathParser.render(pagepath);</code>는 추상화 수준이 중간이다. 그리고<code>.append(“\n”)</code>와 같은 코드는 추상화 수준이 낮다.</p>
<p>한 함수내의 추상화 수준을 섞으면. 코드를 읽는 사람이 헷갈린다.</p>
<h3 id="내려가기-규칙"><a href="#내려가기-규칙" class="headerlink" title="내려가기 규칙"></a>내려가기 규칙</h3><p>코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다. 즉, 위에서 아래로 프로그램을 읽으면서 추상화 수준이 한 단계씩 낮아지는 것이다.</p>
<h3 id="서술적인-이름을-사용하라"><a href="#서술적인-이름을-사용하라" class="headerlink" title="서술적인 이름을 사용하라!"></a>서술적인 이름을 사용하라!</h3><p>함수 이름은 함수 내용이 짐작 가능할 수 있어야 한다. 함수 이름이 길어도 괜찮다. 길고 서술적인 이름이 짧고 어려운 이름보다 좋다. 길고 서술적인 이름이 길고 서술적인 주석보다 좋다. 이름을 정하느라 시간을 들여도 괜찮다.</p>
<h3 id="함수-인수"><a href="#함수-인수" class="headerlink" title="함수 인수"></a>함수 인수</h3><p>함수에서 이상적인 인수 개수는 0개이다. 4개이상은 사용하지 않는게 좋다. </p>
<ol>
<li>인수가 1개인 경우</li>
</ol>
<ul>
<li>인수에 질문을 던지는 경우<ul>
<li>Boolean fileExists(“MyFile”)</li>
</ul>
</li>
<li>인수를 뭔가로 변환해 결과를 반환하는 경우<ul>
<li>InputStream fileOpen(“MyFile”)</li>
</ul>
</li>
<li>이벤트 발생 ⇒ 출력 인수 없이 시스템 상태를 바꾼다.</li>
</ul>
<ol start="2">
<li>플래그 인수</li>
</ol>
<p>플래그 인수는 추하다. 함수로 부울 값을 넘기는 관례는 정말로 끔찍하다. 함수가 한꺼번에 여러 가지를 처리한다고 대놓고 공표하는 셈이니까…!</p>
<ol start="3">
<li>인수가 2개인 함수</li>
</ol>
<ul>
<li>2개가 적절한 경우도 있지만(예, 좌표를 찍는 함수 x축,y축) 단항 함수로 바꾸도록 애써야 한다.</li>
</ul>
<ol start="4">
<li>인수가 3개인 함수</li>
</ol>
<ul>
<li>이해하기 어렵다. 신중히 고려하라..</li>
</ul>
<p>인수 객체가 2-3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Circle <span class="title">makeCircle</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> radius)</span></span></span><br><span class="line"><span class="function">Circle <span class="title">makeCircle</span><span class="params">(Point center, <span class="keyword">double</span> radius)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="명령과-조회를-분리해라"><a href="#명령과-조회를-분리해라" class="headerlink" title="명령과 조회를 분리해라!"></a>명령과 조회를 분리해라!</h3><p>함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중하나만 해야한다. 아래 코드는 명령과 조회를 함께한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(set(<span class="string">"username"</span>, <span class="string">"unclebob"</span>))</span><br></pre></td></tr></table></figure>

<p>명령과 조회를 분리해 혼란을 없애야 한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(attributeExists(<span class="string">"username"</span>))&#123;</span><br><span class="line">	setAttribute(<span class="string">"username"</span>, <span class="string">"unclebob"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="오류-코드보다-예외를-사용하라"><a href="#오류-코드보다-예외를-사용하라" class="headerlink" title="오류 코드보다 예외를 사용하라!"></a>오류 코드보다 예외를 사용하라!</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(deletePage(page) == E_OK)</span><br></pre></td></tr></table></figure>

<p>위 코드는 여러 단계로 중첩되는 코드를 야기한다. 오류 코드를 반환하면 호출자는 오류 코드를 바로 처리해야 한다. 반면 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리되므로 코드가 깔끔해진다.</p>
<p><strong>&lt; Clean Code &gt; 도서의 내용을 공부하며 요약 정리하였습니다.</strong></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-06-06T05:43:06.000Z" title="2020-06-06T05:43:06.000Z">2020-06-06</time><span class="level-item"><a class="link-muted" href="/categories/Study/">Study</a><span> / </span><a class="link-muted" href="/categories/Study/Network/">Network</a></span><span class="level-item">6 minutes read (About 955 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/06/study1-2/">CORS(Cross Origin Resource Sharing)</a></h1><div class="content"><br/>

<p>CORS란, 오리진(출처, 도메인) 사이에 리소스(자원)를 공유하는 방법을 말한다. 여기서 리소스 공유는 <code>XMLHttpRequest</code>나 <code>Fetch API</code>를 통하여 다른 출처의 자원에 접근하는 것이다. 보안을 위해 모든 서버에서 누구나 접근하는 것을 막고 클라이언트에서 서버로 액세스하기 직전까지의 권한을 확인한다.</p>
<p>보안 상의 이유로, 브라우저는 스크립트에서 시작한 서로 다른 출처의 HTTP 요청을 제한한다. XMLHttpRequest와 Fetch API를 사용하는 웹 애플리케이션은 자신의 출처와 동일한 리소스만 불러올 수 있으며, 예외적으로 다른 출처의 리소스를 불러오려면 자신의 출처를 증명할 수 있는 올바른 CORS 헤더를 포함해야 한다.</p>
<p>CORS에는 프리플라이트 요청을 하지않는 <code>simple cross-origin request</code>와 프리플라이트 요청이 필요한 <code>actual request</code>로 나뉜다. 프리플라이트(prefligt) 요청은 실제 통신 전에 권한을 확인하려 보내는 요청이다.</p>
<h3 id="Simple-Cross-Origin-Request"><a href="#Simple-Cross-Origin-Request" class="headerlink" title="Simple Cross-Origin Request"></a>Simple Cross-Origin Request</h3><p><code>simple cross-origin request</code>가 되는 조건은 다음 3가지이다.</p>
<ul>
<li>http 요청 메서드가 단순 메서드(GET, POST, HEAD)</li>
<li>헤더가 모드 심플 헤더(accept, accept-language, content-language, content-type 이외는 제외)</li>
<li>Content-type을 포함하는 경우, 그 값이 applicatin/x-www-form-urlencoded, multipart/form-data, text-plain 중 하나</li>
</ul>
<h3 id="프리플라이트-요청"><a href="#프리플라이트-요청" class="headerlink" title="프리플라이트 요청"></a>프리플라이트 요청</h3><p><code>simple cross-origin request</code> 조건에 맞지 않는 경우 프리플라이트 요청이 필수이다. 프리플라이트를 할 때 클라이언트는 아래 헤더를 붙여 <code>OPTIONS</code>메서드로 전송한다.</p>
<ul>
<li>Access-control-request-method 요청헤더 : 통신을 허용하길 원하는 메서드 지정</li>
<li>Access-control-reqeust-headers 요청 헤더: 허용하길 원하는 헤더를 쉼표로 구분해 나열</li>
<li>Origin 요청 헤더 : 통신 출처 웹 페이지의 도메인 이름을 지정</li>
</ul>
<p>프리플라이트 요청을 받고 나면, 서버측은 허용하는 통신 내용을 아래 헤더를 사용해 브라우저 측에 전달한다. 허용하지 않는 경우 각각의 헤더가 부여되지 않거나 <code>stauts = 401 forbidden</code>으로 반환되기도 한다.</p>
<ul>
<li>Access-control-allow-origin 응답헤더 : 통신을 허용할 오리진 이름. 쿠키를 이용하지 않을 때는 와일드카드(*)로 모든 도메인을 일괄적으로 허용하기도 한다.</li>
<li>Access-control-allow-method 응답헤더 : 대상 url에 허용되는 메서드 이름.</li>
<li>Access-control-allow-header 응답헤더 : 대상 url에 허용되는 헤더 이름 목록. 플라이트요청이 필요없는 간단한 헤더는 생략될 수 있다.</li>
<li>Access-control-allow-credentials 응답헤더: 쿠키 등의 자격 증명을 서버가 받는 것을 허용할 때 부여된다. 값으로는 true만 설정할 수 있다.</li>
<li>Access-control-expose-header 응답헤더 : 허용이 아니라 서버에서 반환하는 응답 헤더 중 스크립트에서 참조할 수 있는 헤더 이름목록을 반환한다.</li>
</ul>
<p>통신 내용을 일정 기간 캐시해서 통신을 생략하는 방법도 사양에 포함되어 있다. 이 지시에는 다음 헤더를 사용한다.</p>
<ul>
<li>Access-control-max-age 응답 헤더 : cahce-control을 사용한 캐시와 마찬가지로 캐시 가능한 초 수를 서버에서 클라이언트로 전달한다.</li>
</ul>
<p>프리플라이트 요청이 허용되면 실제 요청을 전송한다.</p>
<p>참고<br><a href="https://developer.mozilla.org/ko/docs/Web/HTTP/CORS">https://developer.mozilla.org/ko/docs/Web/HTTP/CORS</a></p>
<p><strong>&lt;리얼월드 HTTP&gt; 도서의 내용을 요약 정리하고 관련 내용을 추가하였습니다.</strong></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-05-01T05:08:44.000Z" title="2020-05-01T05:08:44.000Z">2020-05-01</time><span class="level-item"><a class="link-muted" href="/categories/Study/">Study</a><span> / </span><a class="link-muted" href="/categories/Study/Network/">Network</a></span><span class="level-item">9 minutes read (About 1336 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/05/01/study1/">DNS와 작동원리</a></h1><div class="content"><br/>

<p>DNS는 Domanin Name System의 약자로, IP주소를 도메인으로 변환하고 도메인을 IP주소로 변환함으로써 통신하게 하는 시스템입니다.<br>온라인 상의 네트워킹을 하는 모든 단말은 IP주소를 갖고 있고 이 IP를 통해 서로 통신합니다.</p>
<ul>
<li>참고: IP주소는 인터넷에 <a href="https://search.naver.com/search.naver?sm=top_hty&fbm=0&ie=utf8&query=%EB%82%B4+IP">내 IP</a>라고 검색하면 확인할 수 있습니다. </li>
</ul>
<p>IP주소는 숫자로 되어있기 때문에 이를 하나씩 기억하고 사용하기란 매우 불편합니다. 그래서 IP주소에 도메인 네임을 붙여서 통신하게 합니다. 네이버에 접근할 때, IP주소가 아닌 <a href="http://www.naver.com">www.naver.com</a> 이라고 치는 것처럼 말이죠.<br>여기서 <code>naver.com</code>이 네이버의 도메인입니다. 도메인의 IP주소는 <code>nslookup</code>명령어로 확인할 수 있습니다. </p></div><a class="article-more button is-small size-small" href="/2020/05/01/study1/#more">Read More</a></article></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3"><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Book/"><span class="level-start"><span class="level-item">Book</span></span><span class="level-end"><span class="level-item tag">11</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Book/%EB%A6%AC%EC%96%BC%EC%9B%94%EB%93%9C-HTTP/"><span class="level-start"><span class="level-item">리얼월드 HTTP</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Book/%EB%B0%91%EB%B0%94%EB%8B%A5%EB%B6%80%ED%84%B0-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-%EB%94%A5%EB%9F%AC%EB%8B%9D/"><span class="level-start"><span class="level-item">밑바닥부터 시작하는 딥러닝</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Book/%EC%9D%B8%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"><span class="level-start"><span class="level-item">인사이드 자바스크립트</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/Project/"><span class="level-start"><span class="level-item">Project</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Project/DeepLearningFromForR/"><span class="level-start"><span class="level-item">DeepLearningFromForR</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Project/Roadmap2020/"><span class="level-start"><span class="level-item">Roadmap2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/Study/"><span class="level-start"><span class="level-item">Study</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Study/ETC/"><span class="level-start"><span class="level-item">ETC</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Study/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Study/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"><span class="level-start"><span class="level-item">운영체제</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">Recent</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-08-23T05:54:03.000Z">2020-08-23</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/23/study3/">IPC - 프로세스간 통신</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Study/">Study</a> / <a class="link-muted" href="/categories/Study/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/">운영체제</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-08-17T05:55:44.000Z">2020-08-17</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/17/study4/">메모리 관리</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Study/">Study</a> / <a class="link-muted" href="/categories/Study/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/">운영체제</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-08-09T08:30:05.000Z">2020-08-09</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/09/project-3/">pytest 사용기 - fixture, scope</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Study/">Study</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-04T05:14:56.000Z">2020-07-04</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/04/study2-2/">&lt;클린 코드&gt; 좋았던 내용 기록하기(7-12장)</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Study/">Study</a> / <a class="link-muted" href="/categories/Study/ETC/">ETC</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-14T06:30:33.000Z">2020-06-14</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/14/study2-1/">&lt;클린 코드&gt; 좋았던 내용 기록하기(1-3장)</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Study/">Study</a> / <a class="link-muted" href="/categories/Study/ETC/">ETC</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/08/"><span class="level-start"><span class="level-item">August 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/07/"><span class="level-start"><span class="level-item">July 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">June 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">May 2020</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">April 2020</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/book/"><span class="tag">book</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dns/"><span class="tag">dns</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/http/"><span class="tag">http</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js/"><span class="tag">js</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/logparser/"><span class="tag">logparser</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/network/"><span class="tag">network</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/programming/"><span class="tag">programming</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/project/"><span class="tag">project</span><span class="tag is-grey-lightest">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pytest/"><span class="tag">pytest</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/roadmap/"><span class="tag">roadmap</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/study/"><span class="tag">study</span><span class="tag is-grey-lightest">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/"><span class="tag">딥러닝</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EB%AA%A8%EB%8D%B8%EB%A7%81/"><span class="tag">모델링</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EB%AA%A8%EB%8D%B8%ED%95%99%EC%8A%B5/"><span class="tag">모델학습</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EB%B0%B1%EC%97%94%EB%93%9C/"><span class="tag">백엔드</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EC%88%9C%EC%A0%84%ED%8C%8C/"><span class="tag">순전파</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EC%97%AD%EC%A0%84%ED%8C%8C/"><span class="tag">역전파</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C/"><span class="tag">프론트엔드</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">개발계발</a><p class="size-small"><span>&copy; 2021 Yejin Jeong</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://jyejin.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: false,
                    fold: ''
                }
            }
        };</script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to Top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>